require open Leo-III-lambdapi-lib.MetaTheorems;
require open Stdlib.PropExt;

/* 
Library on versions of the natural deduction rules over more than just two terms
*/

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// â‡’ //////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


symbol multi_impl : ğ•ƒ o â†’ Ï„ o â†’ Prop;
rule multi_impl ($p0 â¸¬ $p) $p1 â†ª $p0 â‡’ (multi_impl $p $p1)
with multi_impl â–¡ $p0 â†ª $p0;

symbol multi_impl_correct (p : ğ•ƒ o) (p0 p1: Prop): Ï€ ((multi_impl (p0 â¸¬ p) p1) = (p0 â‡’ multi_impl p p1)) â‰”
begin
    induction
        {simplify; assume x0 x1; reflexivity}
        {simplify; assume p0 p h0 p1 p2;
        rewrite h0 p0; reflexivity}
end;


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// âˆ¨ //////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

symbol âˆ¨áµ¢â‚™â‚‚ (c0 : ğ•ƒ o) (c1 : ğ•ƒ o) : Ï€ (disj c1) â†’ Ï€ (disj (c0 ++ c1))â‰”
begin
    induction
        {assume x h;
        refine h}
        {assume x0 l0 h0 l1 h1; simplify;
        rewrite disj_correct;
        refine âˆ¨áµ¢â‚‚ (h0 l1 h1)}
end;

symbol âˆ¨áµ¢â‚™â‚ (c0 : ğ•ƒ o) (c1 : ğ•ƒ o) : Ï€ (disj c0) â†’ Ï€ (disj (c0 ++ c1))â‰”
begin
    induction
        {assume x h; refine âŠ¥â‚‘ h}
        {assume x0 l h0 x1; 
        type h0 x1;
        rewrite disj_correct; assume h1; 
        simplify; 
        rewrite disj_correct;
        refine âˆ¨â‚‘ h1 _ _
            {assume h2;
            refine âˆ¨áµ¢â‚ h2}
            {assume h2;
            refine âˆ¨áµ¢â‚‚ (h0 x1 h2)}}
end;

symbol rem [a : Set]: ğ•ƒ a â†’ â„• â†’ ğ•ƒ a;
rule rem ($l0 â¸¬ $l) ($n +1) â†ª ($l0 â¸¬ (rem $l $n))
with rem  ($l0 â¸¬ $l) 0 â†ª $l
with rem â–¡ _ â†ª â–¡;

symbol âˆ¨â‚‘â‚™ (n : â„•) (c : ğ•ƒ o) (r : Prop) : Ï€(disj c) â†’ Ï€((literal c n â‡’ r)) â†’ Ï€((disj(rem c n)) â‡’ r) â†’ Ï€ r â‰”
begin
    induction
        {induction
            {assume x h0 h1 h2; refine âŠ¥â‚‘ h0}
            {assume l0 l h0 r h1 h2 h3;
             refine âˆ¨â‚‘ (=â‡’ (disj_correct l0 l) h1) _ _
                {assume h4; refine h2 h4}
                {assume h4; refine h3 h4}}}
        {assume n h0; induction
            {assume r h1 h2 h3; refine âŠ¥â‚‘ h1}
            {assume l0 l h1 r h2 h3 h4;
            have H1 : Ï€ ((l0  âˆ¨ (disj (rem l n))) â‡’ r)
                    {rewrite left disj_correct; refine h4};
            refine âˆ¨â‚‘ (em l0) _ _
                {assume h5;
                refine H1 ((âˆ¨áµ¢â‚ [l0] [disj (rem l n)]) h5)}
                {assume h5;
                have l0isâŠ¥ : Ï€ (âŠ¥ = l0)
                    {refine propExt âŠ¥ l0 _ _
                        {assume h6; refine âŠ¥â‚‘ h6}
                         {assume h6; refine h5 h6}};
                refine h0 l r _ h3 _
                    {rewrite left âŠ¥âˆ¨; rewrite l0isâŠ¥;
                    rewrite left disj_correct l0 l; refine h2}
                    {rewrite left âŠ¥âˆ¨ (disj (rem l n)); 
                    rewrite l0isâŠ¥; refine H1}}}}        
end;