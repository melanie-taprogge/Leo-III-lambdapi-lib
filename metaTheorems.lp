/* Library on Meta-Theorems for Disjunctions

-------------------

The library aims to prove the following meta-theorems for disjunctions:

** Permutation Theorem:
   The theorem is instantiated with:
   - A list of natural numbers representing a disjunction.
   - A list of terms of type `o` representing a clause.

   The theorem verifies that the permuted clause still contains all literals of the original clause. 
   If so, it maps the disjunction of the original clause to the disjunction after the permutation.

** Double Literal Deletion Theorem:
   The theorem is instantiated with three lists:
   - A list of natural numbers representing the indices of literals in the original list. 
     For literals occurring multiple times, the index of the first occurrence is used for all of the
     subsequent occurrences. For example, for `Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1)`, this list would be `(0, 1, 2, 1)`.
   - A second list of natural numbers indicating the desired positions of the literals in the clause.
     If for instance the second occurrence of `l1` in `Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1)` should be deleted, the 
     derived clause would be `Ï€ (l0 âˆ¨ l1 âˆ¨ l2)`, and the list that must be provided would be (0, 1, 2).
     To delete the first occurrence of `l1`, and derive the clause `Ï€ (l0 âˆ¨ l2 âˆ¨ l1)`, the list would 
     be (0, 2, 1).
   3. A list of terms of type `o`, representing literals.

   The resulting theorem verifies if each literal from the original clause is still present at least once 
   in the derived clause. If so, it maps the disjunction of the original literals to the disjunction after 
   the desired double literal deletion. This approach allows multiple identical literals to be deleted at once.

** Transformation Theorem:
   This theorem is useful when a rule is applied to only one literal of a clause. 
   For example, consider the clause `Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l3)` and an inference rule `Ï€ l2 â†’ Ï€ l2'`. 
   The transformation theorem can be instantiated with:
   - The list of terms of type `o` representing the original clause.
   - The position of the literal being affected.
   - The inference rule.

   The resulting term maps the original disjunction to one with the transformed literal.

---

** General Concept:
   The general idea behind the permutation and double literal deletion theorems is to evaluate a list of natural 
   numbers representing the positions of literals after respective operations with respect to the list of literals. 
   A computation ensures the operation is admissible:
   - In the case of permutations, all literals must still be present in the permuted clause.
   - In the case of double literal deletion, each literal must still be present at least once.
   If these conditions are fulfilled, the corresponding argument in the theorem will compute to `Ï€ âŠ¤` and can simply
   be instantiated with `âŠ¤áµ¢` (examples are given below).

---

** Defined Operations:
                        `indexes l`: Returns a list of the indices of the list `l`.
                      `eval n l`: Returns the element of the list `l` at index `n`.
                `eval_list ln l`: Takes as arguments a list `ln` of natural numbers and a list `l` and 
                                  returns a list of  the elements of `l` ordered according to the indices in `ln`.
                        `disj l`: Returns the disjunction of all literals in the list `l`.
       `bincludes [a] eqb l1 l2`: For two lists `l1` and `l2` of type `a` and a boolean equality relation `eqb` 
                                  for elements of type `a`, this operation returns `true` if `l2` includes all 
                                  elements of `l1`, and `false` otherwise.
      `preserves_contents ln lo`: Takes a list of natural numbers (`ln`) and a list of terms of type `o` (`lo`) 
                                  as arguments. Returns `true` if every index of `lo` is included in `ln`.
*/

require open Stdlib.Set Stdlib.Prop Stdlib.FOL Stdlib.Eq Stdlib.Nat Stdlib.Bool Stdlib.List Stdlib.Impred;

// eval 

symbol eval : Ï„ nat â†’ ğ•ƒ o â†’ Ï„ o;
rule eval $n $list â†ª nth âŠ¥ $list $n;

assert l0 l1 l2 âŠ¢ eval 1 (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) â‰¡ l1;

opaque symbol eval_ext (l: ğ•ƒ o) (l0 : Ï„ o) (n: Ï„ nat) : 
    Ï€ (eval n l) â†’ Ï€ (eval (n +1) (l0 â¸¬ l)) â‰”
begin
    assume l l0 n;
    simplify;
    assume h1;
    refine h1
end;


// eval_list

symbol eval_list: ğ•ƒ nat â†’ ğ•ƒ o â†’ ğ•ƒ o;
rule eval_list ($n â¸¬ $l) $list â†ª (nth âŠ¥ $list $n) â¸¬ (eval_list $l $list)
with eval_list â–¡ _ â†ª â–¡;

assert l0 l1 l2 âŠ¢ eval_list (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2  â¸¬ l1 â¸¬ â–¡) â‰¡ l1 â¸¬ (l2  â¸¬ (l0 â¸¬ (l1 â¸¬ â–¡)));


// disj

symbol disj : ğ•ƒ o â†’ Ï„ o;
rule disj ($l1 â¸¬ ($c â¸¬ $l)) â†ª ($l1 âˆ¨ disj ($c â¸¬ $l))
with disj ($l1 â¸¬ â–¡) â†ª $l1 
with disj â–¡ â†ª âŠ¥;

assert l0 l1 l2 âŠ¢ Ï€ (disj (l0 â¸¬ l1 â¸¬ l2  â¸¬ l1 â¸¬ â–¡)) â‰¡ Ï€ (l0 âˆ¨ (l1 âˆ¨ (l2  âˆ¨ l1)));

opaque symbol disj_head (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (l0) â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine h1}   
        {assume x0 l1 h1; 
        assume h2; 
        refine âˆ¨áµ¢â‚ h2}
end; 

opaque symbol disj_tail (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (disj l) â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume x1 l1 h1 h2;
        refine âˆ¨áµ¢â‚‚ h2}
end;

opaque symbol disj_correct (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (disj (l0 â¸¬ l)) â†’ Ï€ (l0 âˆ¨ disj l) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine âˆ¨áµ¢â‚ h1}
        {assume x1 l1 h1 h2;
        refine h2}
end;

opaque symbol lit_imp_disj (lit_list: ğ•ƒ o) (pos_list: ğ•ƒ nat) : 
    Ï€ (âˆƒ(Î» x, (eval x lit_list) âˆ§ (âˆˆ eqn x pos_list))) â†’ Ï€ (disj (eval_list pos_list lit_list)) â‰”
begin
    assume lit_list;
    induction
        {simplify;
        assume h1;
        have H0: (Î  x: Ï„ nat, Ï€ ((Î» x1, nth âŠ¥ lit_list x1 âˆ§ âŠ¥) x) â†’ Ï€ âŠ¥)
            {assume x h2;
            refine âˆ§â‚‘â‚‚ h2};
        refine âˆƒâ‚‘ h1 H0}
        {assume n l;
        simplify;
        assume h1 h2;
        have H1 : Î  x: Ï„ nat, Ï€ ((Î» x1, nth âŠ¥ lit_list x1 âˆ§ (eqn x1 n or âˆˆ eqn x1 l)) x) â†’ Ï€ (disj (nth âŠ¥ lit_list n â¸¬ eval_list l lit_list))
            {assume m h3;
            have H0 : Ï€ ((eqn m n) âˆ¨ (âˆˆ eqn m l))
                {refine âˆ¨_istrue [eqn m n] [âˆˆ eqn m l] (âˆ§â‚‘â‚‚ h3)};
            have H1 : Ï€ (eqn m n) â†’ Ï€ (disj (nth âŠ¥ lit_list n â¸¬ eval_list l lit_list))
                {assume h4;
                have H1_0 : Ï€ (nth âŠ¥ lit_list n)
                    {have H1_0_0 : Ï€ (n = m)
                        {symmetry;
                        refine eqn_correct m n h4};
                    rewrite H1_0_0;
                    refine âˆ§â‚‘â‚ h3};
                refine disj_head (nth âŠ¥ lit_list n) (eval_list l lit_list) H1_0};
            have H2 : Ï€ (âˆˆ eqn m l) â†’ Ï€ (disj (nth âŠ¥ lit_list n â¸¬ eval_list l lit_list))
                {assume h4;
                have H2_0 : Ï€ `âˆƒ x, nth âŠ¥ lit_list x âˆ§ (âˆˆ eqn x l)
                    {have H2_0_0 : Ï€ ((Î» x, nth âŠ¥ lit_list x âˆ§ (âˆˆ eqn x l)) m)
                        {refine âˆ§áµ¢ (âˆ§â‚‘â‚ h3) h4};
                    refine âˆƒáµ¢ m H2_0_0};
                refine disj_tail (nth âŠ¥ lit_list n) (eval_list l lit_list) (h1 H2_0)};
            refine âˆ¨â‚‘ H0 H1 H2
            };
        refine âˆƒâ‚‘ h2 H1}   
end;

opaque symbol disj_imp_lit (l: ğ•ƒ o) : 
    Ï€ (disj l) â†’ Ï€ (âˆƒ(Î» (x : Ï„ nat), (eval x l) âˆ§ (âˆˆ eqn x (indexes l)))) â‰”
begin
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume l0 l h1 h2;
        have H0: Ï€ (l0 âˆ¨ disj l)
            {refine disj_correct l0 l h2};
        have H1: Ï€ l0 â†’ Ï€ (`âˆƒ x, (eval x (l0 â¸¬ l)) âˆ§ (âˆˆ eqn x (indexes (l0 â¸¬ l))))
            {assume h3;
            have H1_0 : Ï€ (eval 0 (l0 â¸¬ l))
                {simplify;
                refine h3};
            have H1_1 : Ï€ ((Î» x, eval x (l0 â¸¬ l) âˆ§ (âˆˆ eqn x (indexes (l0 â¸¬ l)))) 0)
                {simplify;
                refine âˆ§áµ¢ H1_0 (0âˆˆindexesâ¸¬ l0 l)};
            refine âˆƒáµ¢ [nat] [(Î» x, eval x (l0 â¸¬ l) âˆ§ (âˆˆ eqn x (indexes (l0 â¸¬ l))))] 0 H1_1};
        have H2: Ï€ (disj l) â†’ Ï€ (`âˆƒ x, (eval x (l0 â¸¬ l)) âˆ§ (âˆˆ eqn x (indexes (l0 â¸¬ l))))
            {assume h3;
            have H2_0 : Î  x0 , Ï€ ((Î» x, eval x l âˆ§ (âˆˆ eqn x (indexes l))) x0) â†’ Ï€ (`âˆƒ x, (eval x (l0 â¸¬ l)) âˆ§ (âˆˆ eqn x (indexes (l0 â¸¬ l))))
                {assume n h4;
                have H2_0_0 : Ï€ ((Î» x , (eval x (l0 â¸¬ l)) âˆ§ (âˆˆ eqn x (indexes (l0 â¸¬ l)))) (n +1))
                    {refine âˆ§áµ¢ (eval_ext l l0 n ((âˆ§â‚‘â‚ h4))) (+1âˆˆindexesâ¸¬ o n l l0 ((âˆ§â‚‘â‚‚ h4)))};
                refine âˆƒáµ¢ [nat] [Î» x , (eval x (l0 â¸¬ l)) âˆ§ (âˆˆ eqn x (indexes (l0 â¸¬ l)))] (n +1) H2_0_0
                };
            refine âˆƒâ‚‘ (h1 h3) [`âˆƒ x, (eval x (l0 â¸¬ l)) âˆ§ (âˆˆ eqn x (indexes (l0 â¸¬ l)))] H2_0};
        refine âˆ¨â‚‘ H0 H1 H2};
end;

opaque symbol x_in_xâ¸¬ [a] (l: ğ•ƒ a) (l0 : Ï„ a) (beq: Ï„ a â†’ Ï„ a â†’ ğ”¹) : 
    (Î  x, Ï€ (beq x x)) â†’ Ï€ (âˆˆ beq l0 (l0 â¸¬ l)) â‰”
begin
    assume a l l0 beq h1;
    refine oráµ¢â‚ [beq l0 l0] (âˆˆ beq l0 l) (h1 l0)
end;

opaque symbol inâ¸¬ [a] (beq: Ï„ a â†’ Ï„ a â†’ ğ”¹) (n m: Ï„ a) (l: ğ•ƒ a) : 
    Ï€ (âˆˆ beq n l) â†’ Ï€ (âˆˆ beq n (m â¸¬ l)) â‰”
begin
    assume a beq n m;
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume n0 l;
        assume h1 h2;
        have H0: Ï€ (beq n n0) â†’  Ï€ (beq n m or (beq n n0 or âˆˆ beq n l))
            {assume h3;
            refine oráµ¢â‚‚ (beq n m) [beq n n0 or âˆˆ beq n l] (oráµ¢â‚ [beq n n0] (âˆˆ beq n l) h3)};
        have H1: Ï€ (âˆˆ beq n l) â†’  Ï€ (beq n m or (beq n n0 or âˆˆ beq n l))
            {assume h3;
            refine oráµ¢â‚‚ (beq n m) [beq n n0 or âˆˆ beq n l] (oráµ¢â‚‚ (beq n n0) [âˆˆ beq n l] h3)};
        refine orâ‚‘ [beq n n0] [âˆˆ beq n l] (beq n m or (beq n n0 or âˆˆ beq n l)) h2 H0 H1}
end;

opaque symbol disj_imp_lit_pos (lit_list: ğ•ƒ o) (pos_list: ğ•ƒ nat): 
    Ï€ (disj (eval_list pos_list lit_list)) â†’ Ï€ (âˆƒ(Î» (x : Ï„ nat), (eval x lit_list) âˆ§ (âˆˆ eqn x pos_list))) â‰”
begin
    assume lit_list;
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume l0 pos_list;
        assume h1 h2;
        have H0: Ï€ ((nth âŠ¥ lit_list l0) âˆ¨ disj (eval_list pos_list lit_list))
            {refine disj_correct (nth âŠ¥ lit_list l0) (eval_list pos_list lit_list) h2};
        have H1: Ï€ (nth âŠ¥ lit_list l0) â†’ Ï€ (`âˆƒ x, eval x lit_list âˆ§ (âˆˆ eqn x (l0 â¸¬ pos_list)))
            {assume h3;
            have H1_0 : Ï€ (eval l0 lit_list)
                {refine h3};
            have H1_1 : Ï€ ((Î» x, eval x lit_list âˆ§ (âˆˆ eqn x (l0 â¸¬ pos_list))) l0)
                {refine âˆ§áµ¢ H1_0 (x_in_xâ¸¬ pos_list l0 eqn (Î» x, (eqn_complete x x (eq_refl x))))};
        refine âˆƒáµ¢ [nat] [Î» x, eval x lit_list âˆ§ (âˆˆ eqn x (l0 â¸¬ pos_list))] l0 H1_1};
        have H2: Ï€ (disj (eval_list pos_list lit_list)) â†’ Ï€ (`âˆƒ x, eval x lit_list âˆ§ (âˆˆ eqn x (l0 â¸¬ pos_list)))
            {assume h3;
            have H2_0: (Î  x: Ï„ nat, Ï€ ((Î» x1, eval x1 lit_list âˆ§ (âˆˆ eqn x1 pos_list)) x) â†’ Ï€ (`âˆƒ x1, eval x1 lit_list âˆ§ (âˆˆ eqn x1 (l0 â¸¬ pos_list))))
                {assume n h4;
                have H2_0_0 : Ï€ ((Î» x, eval x lit_list âˆ§ (âˆˆ eqn x (l0 â¸¬ pos_list))) n)
                    {refine âˆ§áµ¢ (âˆ§â‚‘â‚ h4) (inâ¸¬ eqn n l0 pos_list (âˆ§â‚‘â‚‚ h4))};
                refine âˆƒáµ¢ [nat]  [Î» x , eval x lit_list âˆ§ (âˆˆ eqn x (l0 â¸¬ pos_list))] n H2_0_0};
            refine âˆƒâ‚‘ (h1 h3) [`âˆƒ x, eval x lit_list âˆ§ (âˆˆ eqn x (l0 â¸¬ pos_list))] H2_0};    
        refine âˆ¨â‚‘ H0 H1 H2}
end;


// bincludes

symbol bincludes  [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;
rule bincludes $beq ($k0 â¸¬ $k) $l â†ª (âˆˆ $beq $k0 $l) and (bincludes $beq $k $l)
with bincludes _ â–¡ _ â†ª true;

assert âŠ¢ bincludes eqn (0 â¸¬ 1 â¸¬ â–¡) (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) â‰¡ true;

opaque symbol bincludes_el (n: Ï„ nat) (Ïƒ: ğ•ƒ nat) (ln: ğ•ƒ nat): 
    Ï€ (bincludes eqn ln Ïƒ) â†’ Ï€ (âˆˆ eqn n ln) â†’ Ï€ (âˆˆ eqn n Ïƒ) â‰”
begin
    assume n Ïƒ;
    induction
        {assume h1 h2;
        refine âŠ¥â‚‘ h2}
        {assume m ln h1 h2 h3;
        have H1: Ï€ (eqn n m) â†’ Ï€ (âˆˆ eqn n Ïƒ) 
            {assume h4;
            have H1_0 : Ï€ (n = m)
                {refine eqn_correct n m h4};
            rewrite H1_0;
            refine andâ‚‘â‚ [âˆˆ eqn m Ïƒ] [bincludes eqn ln Ïƒ] h2};
        have H2: Ï€ (âˆˆ eqn n ln) â†’ Ï€ (âˆˆ eqn n Ïƒ)
            {assume h4;
            refine h1 (andâ‚‘â‚‚ [âˆˆ eqn m Ïƒ] [bincludes eqn ln Ïƒ] h2) h4};
        refine orâ‚‘ [eqn n m] [âˆˆ eqn n ln] (âˆˆ eqn n Ïƒ) h3 H1 H2}
end;


// preserves_contents

symbol preserves_contents: ğ•ƒ nat â†’ ğ•ƒ o â†’ ğ”¹;
rule preserves_contents  $f $l â†ª bincludes eqn (indexes $l) $f;

assert l0 l1 l2 âŠ¢ preserves_contents (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) â‰¡ true;

opaque symbol preserves_contents_el (n: Ï„ nat) (Ïƒ : ğ•ƒ nat) (l: ğ•ƒ o) : 
    Ï€ (preserves_contents Ïƒ l) â†’  Ï€ (âˆˆ eqn n (indexes l)) â†’ Ï€ (âˆˆ eqn n Ïƒ) â‰”
begin
    assume n Ïƒ l;
    simplify;
    assume h1 h2;
    refine bincludes_el n Ïƒ (indexes l) h1 h2;   
end;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// meta-therems /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// permutation theorem 

opaque symbol perm_theorem (Ïƒ : ğ•ƒ nat) (c: ğ•ƒ o) : 
    Ï€ (preserves_contents Ïƒ c) â†’ Ï€(disj c) â†’ Ï€(disj (eval_list Ïƒ c)) â‰”
begin
    assume Ïƒ c h1 h2;

    have H1: (Î  x: Ï„ nat, Ï€ ((Î» x1, (eval x1 c) âˆ§ (âˆˆ eqn x1 (indexes c))) x) â†’ Ï€ (âˆƒ(Î» y ,(eval y c) âˆ§ (âˆˆ eqn y Ïƒ))))
        {assume x0 h3;
        refine (âˆƒáµ¢ [nat] [Î» y ,(eval y c) âˆ§ (âˆˆ eqn y Ïƒ)] x0) (âˆ§áµ¢ (âˆ§â‚‘â‚ h3) (preserves_contents_el x0 Ïƒ c h1 (âˆ§â‚‘â‚‚ h3)))};
    
    have H2: Ï€ (âˆƒ(Î» y ,(eval y c) âˆ§ (âˆˆ eqn y Ïƒ)))
        {refine âˆƒâ‚‘ (disj_imp_lit c h2) H1};

    refine  lit_imp_disj c Ïƒ H2;
end;

assert l0 l1 l2 âŠ¢ perm_theorem (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ l0 â¸¬ â–¡) âŠ¤áµ¢ : Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l0) â†’ Ï€ (l1 âˆ¨ l2 âˆ¨ l0 âˆ¨ l0);


// double literal deletion theorem

opaque symbol double_lit_del_theorem (id_list : ğ•ƒ nat) (output_list : ğ•ƒ nat) (c: ğ•ƒ o) : 
    Ï€ (bincludes eqn id_list output_list) â†’ Ï€(disj (eval_list id_list c)) â†’ Ï€(disj (eval_list output_list c)) â‰”
begin
    assume id_list output_list c h1 h2;
    refine lit_imp_disj c output_list _;
    refine âˆƒâ‚‘ (disj_imp_lit_pos c id_list h2) _;
    assume n h3;
    refine (âˆƒáµ¢ [nat] [Î» x, eval x c âˆ§ (âˆˆ eqn x output_list)] n) (âˆ§áµ¢ (âˆ§â‚‘â‚ h3) (bincludes_el n output_list id_list h1 (âˆ§â‚‘â‚‚ h3)))
end;

assert l0 l1 l2 âŠ¢ double_lit_del_theorem (0 â¸¬ 1 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) (0 â¸¬ 1 â¸¬ 2 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) âŠ¤áµ¢ : Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1) â†’ Ï€ (l0 âˆ¨ l1 âˆ¨ l2);


// transformation theorem 

opaque symbol transformation_theorem [l : Ï„ o] (c: ğ•ƒ o) (n : Ï„ nat) : 
    Ï€ ((nth âŠ¥ c n) â‡’ l) â†’ Ï€ (disj c) â†’ Ï€ (disj (set_nth âŠ¥ c n l)) â‰”
begin
    assume l;
    induction
        {simplify;
        assume x h1 h2;
        refine âŠ¥â‚‘ h2}
        {assume x clause h1;
        induction
            {simplify;
            assume h2 h3;
            have H0: Ï€ (x âˆ¨ (disj clause))
                {refine disj_correct x clause h3};
            have H1: Ï€ x â†’ Ï€ (disj (l â¸¬ clause))
                {assume h4;
                refine disj_head l clause (h2 h4)};
            have H2: Ï€ (disj clause) â†’ Ï€ (disj (l â¸¬ clause))
                {assume h4;
                refine disj_tail l clause h4};   
            refine âˆ¨â‚‘ H0 H1 H2}
            {assume n h2 h3 h4;
            have H00: Ï€ (x âˆ¨ (disj clause)) 
                {refine disj_correct x clause h4};
            have H10: Ï€ x â†’ Ï€ (disj (x â¸¬ set_nth âŠ¥ clause n l))
                {assume h5;
                refine disj_head x (set_nth âŠ¥ clause n l) h5};
            have H20:  Ï€ (disj clause) â†’ Ï€ (disj (x â¸¬ set_nth âŠ¥ clause n l))
                {assume h5;
                have H2_0 : Ï€ (disj (set_nth âŠ¥ clause n l))
                    {refine h1 n h3 h5};
                refine disj_tail x (set_nth âŠ¥ clause n l) H2_0};
            refine âˆ¨â‚‘ H00 H10 H20}}
end;

assert l0 l1 l2 l2' âŠ¢ transformation_theorem [l2'] (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) 2 : (Ï€ l2 â†’ Ï€ l2') â†’  Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1) â†’ Ï€ (l0 âˆ¨ l1 âˆ¨ l2' âˆ¨ l1);
