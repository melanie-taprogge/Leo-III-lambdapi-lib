/* Library on Meta-Theorems for Disjunctions and conjunctions

-------------------

The library aims to prove the following meta-theorems for conjunctions and disjunctions:

** Select:
   This theorem is used when we need to isolate a single clause out of a conjunction of clauses. 
   For instance, suppose we have a conjunction of clauses  `Ï€ (c0 âˆ§ c1 âˆ§ c2)` and we want to 
   select the clause at position `id`.

   The theorem is instantiated with:
   - A natural number `id`, the position of the desired clause in the conjunction.
   - A list of clauses `cnf : ğ•ƒ o` representing the conjunction.

   The theorem checks whether `id` is indeed in the indexes of `cnf`.  If it is, then from 
   `Ï€ (conj cnf)` it extracts the single clause `Ï€ (literal cnf id)`. In other words, it maps 
   the entire conjunction of clauses to the one at position `id`.

** Permutate:
   The theorem is instantiated with:
   - A list of natural numbers representing a disjunction.
   - A list of terms of type `o` representing a clause.

   The theorem verifies that the permuted clause still contains all literals of the original clause. 
   If so, it maps the disjunction of the original clause to the disjunction after the permutation.

** Delete:
   The theorem is instantiated with three lists:
   - A list of natural numbers representing the indices of literals in the original list. 
     For literals occurring multiple times, the index of the first occurrence is used for all of the
     subsequent occurrences. For example, for `Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1)`, this list would be `(0, 1, 2, 1)`.
   - A second list of natural numbers indicating the desired positions of the literals in the clause.
     If for instance the second occurrence of `l1` in `Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1)` should be deleted, the 
     derived clause would be `Ï€ (l0 âˆ¨ l1 âˆ¨ l2)`, and the list that must be provided would be (0, 1, 2).
     To delete the first occurrence of `l1`, and derive the clause `Ï€ (l0 âˆ¨ l2 âˆ¨ l1)`, the list would 
     be (0, 2, 1).
   3. A list of terms of type `o`, representing literals.

   The resulting theorem verifies if each literal from the original clause is still present at least once 
   in the derived clause. If so, it maps the disjunction of the original literals to the disjunction after 
   the desired double literal deletion. This approach allows multiple identical literals to be deleted at once.

** Transform:
   This theorem is useful when a rule is applied to only one literal of a clause. 
   For example, consider the clause `Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l3)` and an inference rule `Ï€ l2 â†’ Ï€ l2'`. 
   The transformation theorem can be instantiated with:
   - The list of terms of type `o` representing the original clause.
   - The position of the literal being affected.
   - The inference rule.

   The resulting term maps the original disjunction to one with the transformed literal.

---

** General Concept:
   The general idea behind the permutation and double literal deletion theorems is to evaluate a list of natural 
   numbers representing the positions of literals after respective operations with respect to the list of literals. 
   A computation ensures the operation is admissible:
   - In the case of permutations, all literals must still be present in the permuted clause.
   - In the case of double literal deletion, each literal must still be present at least once.
   If these conditions are fulfilled, the corresponding argument in the theorem will compute to `Ï€ âŠ¤` and can simply
   be instantiated with `âŠ¤áµ¢` (examples are given below).

---

** Defined Operations:
                   `literal n l`: Returns the element of the list `l` of terms of type `o` at index `n`.
                 `literals ln l`: Takes as arguments a list `ln` of natural numbers and a list `l` of terms of 
                                  type `o` and returns a list of  the elements of `l` ordered according to the 
                                  indices in `ln`.
                        `disj l`: Returns the disjunction of all literals in the list `l`.
                        `conj l`: Returns the conjunction of all terms of type `o` in the list `l`.
               `âŠ† [a] eqb l1 l2`: For two lists `l1` and `l2` of type `a` and a boolean equality relation `eqb` 
                                  for elements of type `a`, this operation returns `true` if `l2` includes all 
                                  elements of `l1`, and `false` otherwise.
                      `l1 âŠ†â‚™ l2`: Special case of âŠ† for natural numbers and equality relation `eqn`
      `preserves_contents ln lo`: Takes a list of natural numbers (`ln`) and a list of terms of type `o` (`lo`) 
                                  as arguments. Returns `true` if every index of `lo` is included in `ln`.
*/

require open Stdlib.List Stdlib.PropExt;
  

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// lemmas ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Define some notations corresponding to standard library symbols

symbol âˆˆâ‚™ â‰” âˆˆ eqn;
notation âˆˆâ‚™ infix right 40;

symbol literal â‰” nth âŠ¥;
assert l0 l1 l2 âŠ¢ literal (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) 1 â‰¡ l1;

opaque symbol literal_ext (l: ğ•ƒ o) (l0 : Ï„ o) (n: Ï„ nat) : 
    Ï€ (literal l n) â†’ Ï€ (literal (l0 â¸¬ l) (n +1)) â‰”
begin
    assume l l0 n h1;
    refine h1
end;

symbol literals â‰” nths âŠ¥;
assert l0 l1 l2 âŠ¢ literals (l0 â¸¬ l1 â¸¬ l2  â¸¬ l1 â¸¬ â–¡) (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) â‰¡ l1 â¸¬ (l2  â¸¬ (l0 â¸¬ (l1 â¸¬ â–¡)));


// lemmas on âˆˆâ‚™

symbol indexes_shift (l: ğ•ƒ nat) (n : Ï„ nat):
    Ï€ (istrue ((n +1) âˆˆâ‚™ (map (+1) l)) â‡’ istrue (n âˆˆâ‚™ l))â‰”
begin
    induction
        {assume n x; refine x}
        {assume n0;
        induction
            {assume h0 n h1; refine h1}
            {assume n1 l h0 h1 n2 h2;
            refine orâ‚‘ [eqn n2 n0] [eqn n2 n1 or âˆˆ eqn (n2 +1) (map (+1) l)] (eqn n2 n0 or (eqn n2 n1 or âˆˆ eqn n2 l)) h2 _ _
                {assume h3;
                refine oráµ¢â‚ (eqn n2 n1 or âˆˆ eqn n2 l) h3}
                {assume h3;
                refine oráµ¢â‚‚ (eqn n2 n0) (h1 n2 h3)}}}
end;

symbol indexes_decrement (id : Ï„ nat) (l0: Ï„ o) (l: ğ•ƒ o): 
     Ï€ ((id +1) âˆˆâ‚™ (indexes (l0 â¸¬ l))) â†’ Ï€ (id âˆˆâ‚™ (indexes l))â‰”
begin
    assume id l0 l;
    assume h0; 
    have H1 : Ï€ ((istrue (âˆˆ eqn (id +1) (iota 1 (size l)))) â‡’ (istrue (âˆˆ eqn id (iota 0 (size l)))))
        {have H2: Ï€ (iota 1 (size l) = map (+1) (iota 0 (size l)))
            {refine (eq_sym (mapS_iota (size l) 0))};
        rewrite H2;
        refine indexes_shift (iota 0 (size l)) id};
    refine H1 h0
end;


// disj

symbol disj : ğ•ƒ o â†’ Ï„ o;
rule disj ($l1 â¸¬ ($c â¸¬ $l)) â†ª ($l1 âˆ¨ disj ($c â¸¬ $l))
with disj ($l1 â¸¬ â–¡) â†ª $l1 
with disj â–¡ â†ª âŠ¥;

assert l0 l1 l2 âŠ¢ Ï€ (disj (l0 â¸¬ l1 â¸¬ l2  â¸¬ l1 â¸¬ â–¡)) â‰¡ Ï€ (l0 âˆ¨ (l1 âˆ¨ (l2  âˆ¨ l1)));

opaque symbol disj_head (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (l0) â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine h1}   
        {assume x0 l1 h1 h2; 
        refine âˆ¨áµ¢â‚ h2}
end; 

opaque symbol disj_tail (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ (disj l) â†’ Ï€ (disj (l0 â¸¬ l)) â‰”
begin
    assume l0;
    induction
        {assume h1;
        refine âŠ¥â‚‘ h1}
        {assume x1 l1 h1 h2;
        refine âˆ¨áµ¢â‚‚ h2}
end;

opaque symbol disj_correct (l0 : Ï„ o) (l : ğ•ƒ o) : 
    Ï€ ((disj (l0 â¸¬ l)) = (l0 âˆ¨ disj l)) â‰”
begin
    assume l0;
    induction
        {simplify; 
        rewrite âˆ¨âŠ¥; 
        reflexivity}
        {simplify;
        assume x l h0; 
        reflexivity}
end;

opaque symbol lit_imp_disj (c: ğ•ƒ o) (ks: ğ•ƒ nat) : 
    Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ ks) â†’ Ï€ (disj (literals c ks)) â‰”
begin
    assume c;
    induction
    {assume h1;
        have H0: Î  x: Ï„ nat, Ï€ ((Î» x1, literal c x1 âˆ§ âŠ¥) x) â†’ Ï€ âŠ¥
        {assume x h2;
        refine âˆ§â‚‘â‚‚ h2};
        refine âˆƒâ‚‘ h1 H0}
    {assume n l h1 h2;
        have H1: Î  x: Ï„ nat,
        Ï€ ((Î» x1, literal c x1 âˆ§ (eqn x1 n or x1 âˆˆâ‚™ l)) x)
            â†’ Ï€ (disj (literal c n â¸¬ literals c l))
        {assume m h3;
        have H0: Ï€ (eqn m n âˆ¨ m âˆˆâ‚™ l)
            {refine âˆ¨_istrue [eqn m n] [m âˆˆâ‚™ l] (âˆ§â‚‘â‚‚ h3)};
        have H1: Ï€ (eqn m n) â†’ Ï€ (disj (literal c n â¸¬ literals c l))
            {assume h4;
            have H1_0: Ï€ (literal c n)
                {have H1_0_0: Ï€ (n = m)
                {symmetry;
                refine eqn_correct m n h4};
                rewrite H1_0_0;
                refine âˆ§â‚‘â‚ h3};
            refine disj_head (literal c n) (literals c l) H1_0};
        have H2: Ï€ (m âˆˆâ‚™ l) â†’ Ï€ (disj (literal c n â¸¬ literals c l))
            {assume h4;
            have H2_0: Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ l)
                {have H2_0_0: Ï€ ((Î» x, literal c x âˆ§ x âˆˆâ‚™ l) m)
                {refine âˆ§áµ¢ (âˆ§â‚‘â‚ h3) h4};
                refine âˆƒáµ¢ m H2_0_0};
            refine disj_tail (literal c n) (literals c l) (h1 H2_0)};
        refine âˆ¨â‚‘ H0 H1 H2};
        refine âˆƒâ‚‘ h2 H1}
end;

opaque symbol disj_imp_lit (c: ğ•ƒ o) (ks: ğ•ƒ nat): 
    Ï€ (disj (literals c ks)) â†’ Ï€ (`âˆƒ (x : Ï„ nat), literal c x âˆ§ x âˆˆâ‚™ ks) â‰”
begin
    assume c;
    induction
    {assume h1;
        refine âŠ¥â‚‘ h1}
    {assume l0 ks h1 h2;
        have H0: Ï€ (literal c l0 âˆ¨ disj (literals c ks))
        {refine =â‡’ (disj_correct (literal c l0) (literals c ks)) h2};
        have H1: Ï€ (literal c l0) â†’ Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ (l0 â¸¬ ks))
        {assume h3;
        have H1_0: Ï€ (literal c l0)
            {refine h3};
        have H1_1: Ï€ ((Î» x, literal c x âˆ§ x âˆˆâ‚™ (l0 â¸¬ ks)) l0)
            {refine âˆ§áµ¢ H1_0
            (mem_head eqn l0 ks
                (istrue=true (eqn_complete l0 l0 (eq_refl l0))))};
        refine âˆƒáµ¢ l0 H1_1};
        have H2: Ï€ (disj (literals c ks)) â†’ Ï€ (`âˆƒ x, literal c x âˆ§ x âˆˆâ‚™ (l0 â¸¬ ks))
        {assume h3;
        have H2_0: Î  x: Ï„ nat,
            Ï€ ((Î» x1, literal c x1 âˆ§ x1 âˆˆâ‚™ ks) x)
                â†’ Ï€ (`âˆƒ x1, literal c x1 âˆ§ x1 âˆˆâ‚™ (l0 â¸¬ ks))
            {assume n h4;
            have H2_0_0: Ï€ ((Î» x, literal c x âˆ§ x âˆˆâ‚™ (l0 â¸¬ ks)) n)
                {refine âˆ§áµ¢ (âˆ§â‚‘â‚ h4) (mem_tail eqn n l0 ks (âˆ§â‚‘â‚‚ h4))};
            refine âˆƒáµ¢ n H2_0_0};
        refine âˆƒâ‚‘ (h1 h3) H2_0};
        refine âˆ¨â‚‘ H0 H1 H2}
end;   


// conj

symbol conj : ğ•ƒ o â†’ Ï„ o;
rule conj ($l1 â¸¬ ($c â¸¬ $l)) â†ª ($l1 âˆ§ conj ($c â¸¬ $l))
with conj ($l1 â¸¬ â–¡) â†ª $l1 
with conj â–¡ â†ª âŠ¤;

assert l0 l1 l2 âŠ¢ Ï€ (conj (l0 â¸¬ l1 â¸¬ l2  â¸¬ l1 â¸¬ â–¡)) â‰¡ Ï€ (l0 âˆ§ (l1 âˆ§ (l2  âˆ§ l1)));

opaque symbol conj_head (c0 : Ï„ o) (c : ğ•ƒ o) : 
     Ï€ (conj (c0 â¸¬ c)) â†’ Ï€ (c0) â‰”
begin
    assume c0;
    induction
        {assume h1;
        refine h1}   
        {assume x0 c1 h1 h2;
        refine âˆ§â‚‘â‚ h2}
end; 

opaque symbol conj_tail (c0 : Ï„ o) (c : ğ•ƒ o) : 
     Ï€ (conj (c0 â¸¬ c)) â†’ Ï€ (conj c) â‰”
begin
    assume c0;
    induction
        {assume h1;
        refine âŠ¤áµ¢}   
        {assume x0 c1 h1 h2; 
        refine âˆ§â‚‘â‚‚ h2}
end; 

opaque symbol conj_correct (c0 : Ï„ o) (c : ğ•ƒ o) : 
    Ï€ (conj (c0 â¸¬ c)) â†’ Ï€ (c0 âˆ§ conj c) â‰”
begin
    assume c0;
    induction
        {assume h1;
        refine âˆ§áµ¢ h1 âŠ¤áµ¢}
        {assume x1 c1 h1 h2;
        refine h2}
end;


// âŠ†

symbol âŠ†  [a] : (Ï„ a â†’ Ï„ a â†’ ğ”¹) â†’ ğ•ƒ a â†’ ğ•ƒ a â†’ ğ”¹;
rule âŠ† $beq ($k0 â¸¬ $k) $l â†ª (âˆˆ $beq $k0 $l) and (âŠ† $beq $k $l)
with âŠ† _ â–¡ _ â†ª true;

symbol âŠ†â‚™ â‰” âŠ† eqn;
notation âŠ†â‚™ infix right 30.000000;

assert âŠ¢ (0 â¸¬ 1 â¸¬ â–¡) âŠ†â‚™ (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) â‰¡ true;

opaque symbol âŠ†â‚™_el (n: Ï„ nat) (Ïƒ: ğ•ƒ nat) (ln: ğ•ƒ nat): 
    Ï€ (ln âŠ†â‚™ Ïƒ) â†’ Ï€ (n âˆˆâ‚™ ln) â†’ Ï€ (n âˆˆâ‚™ Ïƒ) â‰”
begin
    assume n Ïƒ;
    induction
    {assume h1 h2;
        refine âŠ¥â‚‘ h2}
    {assume m ln h1 h2 h3;
        have H1: Ï€ (eqn n m) â†’ Ï€ (n âˆˆâ‚™ Ïƒ)
        {assume h4;
        have H1_0: Ï€ (n = m)
            {refine eqn_correct n m h4};
        rewrite H1_0;
        refine andâ‚‘â‚ [âˆˆ eqn m Ïƒ] [âŠ† eqn ln Ïƒ] h2};
        have H2: Ï€ (n âˆˆâ‚™ ln) â†’ Ï€ (n âˆˆâ‚™ Ïƒ)
            {assume h4;
            refine h1 (andâ‚‘â‚‚ [âˆˆ eqn m Ïƒ] [âŠ† eqn ln Ïƒ] h2) h4};
        refine orâ‚‘ [eqn n m] [n âˆˆâ‚™ ln] (n âˆˆâ‚™ Ïƒ) h3 H1 H2}
end;


// preserves_contents

symbol preserves_contents: ğ•ƒ nat â†’ ğ•ƒ o â†’ ğ”¹;
rule preserves_contents  $f $l â†ª (indexes $l) âŠ†â‚™ $f;

assert l0 l1 l2 âŠ¢ 
    preserves_contents (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) â‰¡ true;

opaque symbol preserves_contents_correct (n: Ï„ nat) (Ïƒ : ğ•ƒ nat) (l: ğ•ƒ o) : 
    Ï€ (preserves_contents Ïƒ l) â†’  Ï€ (n âˆˆâ‚™ (indexes l)) â†’ Ï€ (n âˆˆâ‚™ Ïƒ) â‰”
begin
    assume n Ïƒ l h1 h2;
    refine âŠ†â‚™_el n Ïƒ (indexes l) h1 h2;   
end;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// meta-therems /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// clause selection theorem

opaque symbol select (id : Ï„ nat) (cnf: ğ•ƒ o) : 
    Ï€ (id âˆˆâ‚™ (indexes cnf)) â†’ Ï€ (conj cnf) â†’ Ï€ (literal cnf id) â‰”
begin
    induction 
        {induction
            {assume h0 h1; refine h0}
            {assume x cnf h0 h1 h2; 
            refine conj_head x cnf h2}}
        {assume id h0;
        induction
            {assume b; refine âŠ¥â‚‘ b}
            {assume x cnf h1 h2 h3;
            have ConjImpCl : Ï€ (conj cnf â‡’ literal cnf id)
                {refine h0 cnf (indexes_decrement id x cnf h2)};
            refine literal_ext cnf x id (ConjImpCl (conj_tail x cnf h3))}}
end;

assert c0 c1 c2 c2' âŠ¢ select 2 (c0 â¸¬ c1 â¸¬ c2 â¸¬ c1 â¸¬ â–¡): 
    (Ï€ âŠ¤) â†’  Ï€ (c0 âˆ§ c1 âˆ§ c2 âˆ§ c1) â†’ Ï€ (c2);


// permutation theorem 

opaque symbol permute (Ïƒ : ğ•ƒ nat) (c: ğ•ƒ o) : 
    Ï€ (preserves_contents Ïƒ c) â†’ Ï€(disj c) â†’ Ï€(disj (literals c Ïƒ)) â‰”
begin
    assume Ïƒ c h1 h2;
    
    have H1: Î  x: Ï„ nat,
        Ï€ ((Î» x1, literal c x1 âˆ§ x1 âˆˆâ‚™ indexes c) x)
        â†’ Ï€ (`âˆƒ y, literal c y âˆ§ y âˆˆâ‚™ Ïƒ)
        {assume x0 h3;
        refine âˆƒáµ¢ x0 (âˆ§áµ¢ (âˆ§â‚‘â‚ h3) (preserves_contents_correct x0 Ïƒ c h1 (âˆ§â‚‘â‚‚ h3)))};
    
    have H2: Ï€ (`âˆƒ y, literal c y âˆ§ y âˆˆâ‚™ Ïƒ)
        {have H3: Ï€ (disj (nths âŠ¥ c (indexes c)))
            {rewrite nths_indexes_id âŠ¥ c;
            refine h2};
        refine âˆƒâ‚‘ (disj_imp_lit c (indexes c) H3) H1};
    refine lit_imp_disj c Ïƒ H2
end;

assert l0 l1 l2 âŠ¢ permute (1 â¸¬ 2 â¸¬ 0 â¸¬ 3 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ l0 â¸¬ â–¡) âŠ¤áµ¢ : 
    Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l0) â†’ Ï€ (l1 âˆ¨ l2 âˆ¨ l0 âˆ¨ l0);



// double literal deletion theorem

opaque symbol delete (id_list : ğ•ƒ nat) (output_list : ğ•ƒ nat) (c: ğ•ƒ o) : 
    Ï€ (id_list âŠ†â‚™ output_list) â†’ Ï€(disj (literals c id_list)) â†’ Ï€(disj (literals c output_list)) â‰”
begin
    assume id_list output_list c h1 h2;
    refine lit_imp_disj c output_list _;
    refine âˆƒâ‚‘ (disj_imp_lit c id_list h2) _;
    assume n h3;
    refine âˆƒáµ¢ n (âˆ§áµ¢ (âˆ§â‚‘â‚ h3)
        (âŠ†â‚™_el n output_list id_list h1 (âˆ§â‚‘â‚‚ h3)))
end;    

assert l0 l1 l2 âŠ¢ delete (0 â¸¬ 1 â¸¬ 2 â¸¬ 1 â¸¬ â–¡) (0 â¸¬ 1 â¸¬ 2 â¸¬ â–¡) (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) âŠ¤áµ¢ : 
    Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1) â†’ Ï€ (l0 âˆ¨ l1 âˆ¨ l2);


// transformation theorem 

opaque symbol transform [l : Ï„ o] (c: ğ•ƒ o) (n : Ï„ nat) : 
Ï€ ((literal c n) â‡’ l) â†’ Ï€ (disj c) â†’ Ï€ (disj (set_nth âŠ¥ c n l)) â‰”
begin
    assume l;
    induction
    {assume x h1 h2;
        refine âŠ¥â‚‘ h2}
    {assume x clause h1;
        induction
            {assume h2 h3;
            have H0: Ï€ (x âˆ¨ disj clause)
                {refine =â‡’ (disj_correct x clause) h3};
            have H1: Ï€ x â†’ Ï€ (disj (l â¸¬ clause))
                {assume h4;
                refine disj_head l clause (h2 h4)};
            have H2: Ï€ (disj clause) â†’ Ï€ (disj (l â¸¬ clause))
                {assume h4;
                refine disj_tail l clause h4};
            refine âˆ¨â‚‘ H0 H1 H2}
            {assume n h2 h3 h4;
            have H00: Ï€ (x âˆ¨ disj clause)
                {refine =â‡’ (disj_correct x clause) h4};
            have H10: Ï€ x â†’ Ï€ (disj (x â¸¬ set_nth âŠ¥ clause n l))
                {assume h5;
                refine disj_head x (set_nth âŠ¥ clause n l) h5};
            have H20: Ï€ (disj clause) â†’ Ï€ (disj (x â¸¬ set_nth âŠ¥ clause n l))
                {assume h5;
                have H2_0: Ï€ (disj (set_nth âŠ¥ clause n l))
                    {refine h1 n h3 h5};
                refine disj_tail x (set_nth âŠ¥ clause n l) H2_0};
            refine âˆ¨â‚‘ H00 H10 H20}}
end;

assert l0 l1 l2 l2' âŠ¢ transform [l2'] (l0 â¸¬ l1 â¸¬ l2 â¸¬ l1 â¸¬ â–¡) 2 : 
    (Ï€ l2 â†’ Ï€ l2') â†’  Ï€ (l0 âˆ¨ l1 âˆ¨ l2 âˆ¨ l1) â†’ Ï€ (l0 âˆ¨ l1 âˆ¨ l2' âˆ¨ l1);
