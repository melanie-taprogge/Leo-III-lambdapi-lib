require open Stdlib.Set Stdlib.Prop Stdlib.Classic Stdlib.FOL Stdlib.HOL Stdlib.Eq Stdlib.Impred Stdlib.FunExt Stdlib.PropExt Stdlib.Nat Stdlib.Bool Stdlib.List Leo-III-lambdapi-lib.Epsilon Leo-III-lambdapi-lib.CNFeq;

 constant symbol Tactic : TYPE;
 symbol tactic : Set;
 rule Ï„ tactic â†ª Tactic;

 constant symbol String : TYPE;
 builtin "String" â‰” String;
 constant symbol string : Set;
 rule Ï„ string â†ª String;
 
 symbol #rewrite : String â†’ String â†’ Î  [a], Ï€ a â†’ Tactic;
 builtin "rewrite" â‰” #rewrite;
 
 symbol #orelse : Tactic â†’ Tactic â†’ Tactic;
 builtin "orelse" â‰” #orelse;
 notation #orelse infix left 10000;
 
 symbol #refine : String â†’ Tactic;
 builtin "refine" â‰” #refine;
 
 symbol #repeat : Tactic â†’ Tactic;
 builtin "repeat" â‰” #repeat;
 
 symbol #fail : Tactic;
 builtin "fail" â‰” #fail;
 
 symbol #admit : Tactic;
 builtin "admit" â‰” #admit;
 
 symbol #and : Tactic â†’ Tactic â†’ Tactic;
 builtin "and" â‰” #and;
 
 symbol #apply : Î  [a], Ï€ a â†’ Tactic;
 builtin "apply" â‰” #apply;
 
 symbol #assume : String â†’ Tactic;
 builtin "assume" â‰” #assume;
 
 symbol #generalize : Î  [a], Ï€ a â†’ Tactic;
 builtin "generalize" â‰” #generalize;
 
 symbol #have : String â†’ Î  [a], Ï€ a â†’ Tactic;
 builtin "have" â‰” #have; 
 
 symbol #induction : Tactic;
 builtin "induction" â‰” #induction; 
 
 symbol #remove : Î  [a], Ï€ a â†’ Tactic;
 builtin "remove" â‰” #remove;
 
 symbol #reflexivity : Tactic;
 builtin "reflexivity" â‰” #reflexivity;
 
 symbol #set : String â†’ Î  [a], Ï€ a â†’ Tactic;
 builtin "set" â‰” #set;
 
 symbol #simplify : Tactic;
 builtin "simplify" â‰” #simplify;

 symbol #simplify_beta : Tactic;
 builtin "simplify rule off" â‰” #simplify_beta;
 
 symbol #solve : Tactic;
 builtin "solve" â‰” #solve;
 
 symbol #symmetry : Tactic;
 builtin "symmetry" â‰” #symmetry;
 
 symbol #try : Tactic â†’ Tactic;
 builtin "try" â‰” #try;
 
 symbol #why3 : Tactic;
 builtin "why3" â‰” #why3; 

 symbol #change : Tactic;
 builtin "change" â‰” #change;
 
 // necessary in order to define the tactics
 protected symbol set0 : Set;
 rule Ï„ set0 â†ª Set;


 /******************************************************************************
 *  Setup for the user defined tactic         
 ******************************************************************************/
 
  
symbol applyAny : ğ•ƒ tactic â†’ Tactic;
 rule applyAny ($t0 â¸¬ ($t1 â¸¬ $tl)) â†ª $t0 #orelse (applyAny ($t1 â¸¬ $tl))
 with applyAny ($t0 â¸¬ â–¡) â†ª $t0;
 
 symbol listOfAllSimpRules â‰” ((#rewrite "" "" âˆ¨_idem) â¸¬ (#rewrite "" "" em_eq_l) â¸¬ (#rewrite "" "" em_eq_r) â¸¬ (#rewrite "" "" âˆ¨âŠ¤) â¸¬ 
     (#rewrite "" "" âŠ¤âˆ¨) â¸¬ (#rewrite "" "" âˆ¨âŠ¥) â¸¬ (#rewrite "" "" âŠ¥âˆ¨) â¸¬ (#rewrite "" "" âˆ§_idem) â¸¬ (#rewrite "" "" âˆ§_contra_r) â¸¬ (#rewrite "" "" âˆ§_contra_l) â¸¬ 
     (#rewrite "" "" âˆ§âŠ¤) â¸¬ (#rewrite "" "" âŠ¤âˆ§) â¸¬ (#rewrite "" "" âˆ§âŠ¥) â¸¬ (#rewrite "" "" âŠ¥âˆ§) â¸¬ (#rewrite "" "" â‡’âŠ¤) â¸¬ (#rewrite "" "" âŠ¥â‡’) â¸¬ (#rewrite "" "" âŠ¤â‡’) â¸¬ 
     (#rewrite "" "" â‡’âŠ¥) â¸¬ (#rewrite "" "" â‡’_idem) â¸¬ (#rewrite "" "" â‡”âŠ¤) â¸¬ (#rewrite "" "" âŠ¤â‡”) â¸¬ (#rewrite "" "" âŠ¥â‡”) â¸¬ (#rewrite "" "" â‡”âŠ¥) â¸¬ 
     (#rewrite "" "" â‡”_idem) â¸¬ (#rewrite "" "" Â¬âŠ¤) â¸¬ (#rewrite "" "" Â¬âŠ¥) â¸¬ (#rewrite "" "" Â¬Â¬â‚‘_eq) â¸¬ (#rewrite "" "" =âŠ¤) â¸¬ (#rewrite "" "" âŠ¤=) â¸¬ 
     (#rewrite "" "" =âŠ¥) â¸¬ (#rewrite "" "" âŠ¥=) â¸¬ (#rewrite "" "" =_idem) â¸¬ (#rewrite "" "" Â¬=âŠ¥) â¸¬ (#rewrite "" "" Â¬âŠ¥=) â¸¬ (#rewrite "" "" Â¬=âŠ¤) â¸¬ 
     (#rewrite "" "" Â¬âŠ¤=) â¸¬ (#rewrite "" "" Â¬=_idem) â¸¬ (#rewrite "" "" âˆ€_const) â¸¬ (#rewrite "" "" âˆƒ_const) â¸¬ (#rewrite "" "" Â¬x=_idem) â¸¬ (#rewrite "" "" =Â¬x_idem) â¸¬ 
     (#rewrite "" "" polarity_switch) â¸¬ (#refine "âŠ¤áµ¢") â¸¬ â–¡);
     // the rules and ... are added as Leo omits trivially false literals, we account for this using this rule
 
 symbol applyAllSimplifications â‰” #repeat (applyAny listOfAllSimpRules);


/******************************************************************************
*  Definition of Leo-III clausification tactic        
******************************************************************************/

symbol normAsso â‰” #repeat ((#rewrite "" "" âˆ§_assoc) #orelse (#rewrite "" "" âˆ¨_assoc));

symbol normAsso_âˆ¨ â‰” #repeat (#rewrite "" "" âˆ¨_assoc);

symbol normAsso_âˆ§ â‰” #repeat (#rewrite "" "" âˆ§_assoc);

symbol allCNFids_list â‰” ((#rewrite "" "" deMorgan_âˆ§) â¸¬ (#rewrite "" "" deMorgan_âˆ¨) â¸¬ (#rewrite "" "" â‡’=âˆ¨) â¸¬ (#rewrite "" "" Â¬â‡’=âˆ§Â¬) â¸¬ (#and (#rewrite "" "" âˆ§âˆ¨_dist_l) normAsso) â¸¬ (#and (#rewrite "" "" âˆ§âˆ¨_dist_r) normAsso) â¸¬ (#rewrite "" "" Â¬Â¬â‚‘_eq) â¸¬ (#rewrite "" "" âˆ¨_assoc) â¸¬ (#rewrite "" "" âˆ§_assoc) â¸¬ â–¡);

symbol boolIds â‰” (applyAny allCNFids_list);

symbol tryVars: ğ•ƒ string â†’ Tactic; 
rule tryVars ($v0 â¸¬ ($v1 â¸¬ $vs)) â†ª (#assume $v0) #orelse (tryVars ($v1 â¸¬ $vs))
with tryVars ($v0 â¸¬ â–¡) â†ª (#assume $v0);

symbol move_âˆ€_out (varList: ğ•ƒ string) â‰” #repeat (((#rewrite "" "" âˆ€âˆ§_dist_r) #orelse (#rewrite  "" "" âˆ€âˆ§_dist_l) #orelse (#rewrite  "" "" âˆ€âˆ¨_dist_r) #orelse (#rewrite "" "" âˆ€âˆ¨_dist_l)) #orelse (#and (#and (#refine "âˆ€_ext _ _ _") (#simplify_beta))) (tryVars varList));

symbol move_Â¬âˆƒ_out (varList: ğ•ƒ string) â‰” (#and (#rewrite "" "" Â¬âˆƒ=âˆ€Â¬) (move_âˆ€_out varList));

symbol generalizeQuant (varList: ğ•ƒ string) â‰” (move_âˆ€_out varList) #orelse (move_Â¬âˆƒ_out varList);

symbol skolemProzess_âˆƒ sk_def : Tactic â‰” (#and (#and (#rewrite "" "" âˆƒ_skolem) #simplify_beta) sk_def);

symbol skolemProzess_âˆ€ sk_def : Tactic â‰” (#and (#and (#rewrite "" "" âˆ€_skolem) #simplify_beta) sk_def);

symbol skolemProzess sk_def : Tactic â‰” (skolemProzess_âˆ€ sk_def) #orelse (skolemProzess_âˆƒ sk_def);

symbol stepwise_quants: ğ•ƒ tactic â†’ Tactic;
rule stepwise_quants ($sk1 â¸¬ ($sk2 â¸¬ $sk3)) â†ª #repeat ((#and $sk1 (stepwise_quants ($sk2 â¸¬ $sk3))) #orelse boolIds)
with stepwise_quants ($sk1 â¸¬ â–¡) â†ª #and (#repeat ($sk1 #orelse boolIds)) #reflexivity;

symbol move_âˆ€_out2 (assumeVar: Tactic) â‰” ((#and (#and (((#and (#repeat  (#rewrite "" ".[x in x = _]" Â¬Â¬â‚‘_eq)) (#refine "âˆ€_ext _"))) #orelse (#refine "âˆ€_ext _")) (#simplify_beta)) assumeVar) #orelse ((#rewrite "" "" âˆ€âˆ§_dist_r) #orelse (#rewrite  "" "" âˆ€âˆ§_dist_l) #orelse (#rewrite  "" "" âˆ€âˆ¨_dist_r) #orelse (#rewrite "" "" âˆ€âˆ¨_dist_l)));
symbol move_Â¬âˆƒ_out2 (assumeVar: Tactic) â‰” (#and (#rewrite "" "" Â¬âˆƒ=âˆ€Â¬) (move_âˆ€_out2 assumeVar));

symbol singleStepQuant: Tactic â†’ Tactic;
rule singleStepQuant $t â†ª #repeat ($t #orelse boolIds);

symbol lastStepQuant: Tactic â†’ Tactic;
rule lastStepQuant $t â†ª #and (#repeat ($t #orelse boolIds)) #reflexivity;

symbol stepwise_skolem0: ğ•ƒ tactic â†’ Tactic;
rule stepwise_skolem0 ($sk1 â¸¬ ($sk2 â¸¬ $sk3)) â†ª #repeat ((#and (skolemProzess $sk1) (stepwise_skolem0 ($sk2 â¸¬ $sk3))) #orelse boolIds)
with stepwise_skolem0 ($sk1 â¸¬ â–¡) â†ª #and (#repeat ((skolemProzess $sk1) #orelse boolIds)) #reflexivity;

symbol stepwise_skolem: (Tactic â†’ Tactic) â†’ ğ•ƒ tactic â†’ Tactic;
rule stepwise_skolem $t ($sk1 â¸¬ ($sk2 â¸¬ $sk3)) â†ª #repeat ((#and ($t $sk1) (stepwise_skolem $t ($sk2 â¸¬ $sk3))) #orelse boolIds)
with stepwise_skolem $t ($sk1 â¸¬ â–¡) â†ª #and (#repeat (($t $sk1) #orelse boolIds)) #reflexivity;

symbol handleQuants (varList: ğ•ƒ string) (allSkolemRW : ğ•ƒ tactic) â‰” ((stepwise_skolem skolemProzess_âˆ€ allSkolemRW) #orelse (move_âˆ€_out varList)) #orelse ((move_Â¬âˆƒ_out varList) #orelse (stepwise_skolem skolemProzess_âˆƒ allSkolemRW));

symbol onlyBoolIds â‰” #and (#repeat boolIds) #reflexivity;

symbol cnfTac : ğ•ƒ string â†’ ğ•ƒ tactic â†’ Tactic;
rule cnfTac â–¡ â–¡ â†ª #and (#repeat boolIds) #reflexivity
with cnfTac ($v0 â¸¬ $v) â–¡ â†ª  #repeat ((generalizeQuant ($v0 â¸¬ $v)) #orelse boolIds)
with cnfTac â–¡ ($s0 â¸¬ $s) â†ª  stepwise_skolem skolemProzess ($s0 â¸¬ $s)
with cnfTac ($v0 â¸¬ $v) ($s0 â¸¬ $s) â†ª #repeat ((handleQuants ($v0 â¸¬ $v) ($s0 â¸¬ $s)) #orelse boolIds);