require open Stdlib.Set Stdlib.Prop Stdlib.Classic Stdlib.FOL Stdlib.HOL Stdlib.Eq Stdlib.Impred Stdlib.FunExt Stdlib.PropExt Stdlib.Nat Stdlib.Bool Stdlib.List Stdlib.Epsilon Leo-III-lambdapi-lib.CNFeq;


/******************************************************************************
 *  Setup for the user defined tactic         
 ******************************************************************************/

 constant symbol Tactic : TYPE;
 symbol tactic : Set;
 rule Ï„ tactic â†ª Tactic;

 constant symbol String : TYPE;
 builtin "String" â‰” String;
 constant symbol string : Set;
 rule Ï„ string â†ª String;
 
 symbol #rewrite : String â†’ String â†’ Î  [a], Ï€ a â†’ Tactic;
 builtin "rewrite" â‰” #rewrite;
 
 symbol #orelse : Tactic â†’ Tactic â†’ Tactic;
 builtin "orelse" â‰” #orelse;
 notation #orelse infix left 10000;
 
 symbol #refine : String â†’ Tactic;
 builtin "refine" â‰” #refine;
 
 symbol #repeat : Tactic â†’ Tactic;
 builtin "repeat" â‰” #repeat;
 
 symbol #fail : Tactic;
 builtin "fail" â‰” #fail;
 
 symbol #admit : Tactic;
 builtin "admit" â‰” #admit;
 
 symbol #and : Tactic â†’ Tactic â†’ Tactic;
 builtin "and" â‰” #and;
 
 symbol #apply : Î  [a], Ï€ a â†’ Tactic;
 builtin "apply" â‰” #apply;
 
 symbol #assume : String â†’ Tactic;
 builtin "assume" â‰” #assume;
 
 symbol #generalize : Î  [a], Ï€ a â†’ Tactic;
 builtin "generalize" â‰” #generalize;
 
 symbol #have : String â†’ Î  [a], Ï€ a â†’ Tactic;
 builtin "have" â‰” #have; 
 
 symbol #induction : Tactic;
 builtin "induction" â‰” #induction; 
 
 symbol #remove : Î  [a], Ï€ a â†’ Tactic;
 builtin "remove" â‰” #remove;
 
 symbol #reflexivity : Tactic;
 builtin "reflexivity" â‰” #reflexivity;
 
 symbol #set : String â†’ Î  [a], Ï€ a â†’ Tactic;
 builtin "set" â‰” #set;
 
 symbol #simplify : Tactic;
 builtin "simplify" â‰” #simplify;

 symbol #simplify_beta : Tactic;
 builtin "simplify rule off" â‰” #simplify_beta;
 
 symbol #solve : Tactic;
 builtin "solve" â‰” #solve;
 
 symbol #symmetry : Tactic;
 builtin "symmetry" â‰” #symmetry;
 
 symbol #try : Tactic â†’ Tactic;
 builtin "try" â‰” #try;
 
 symbol #why3 : Tactic;
 builtin "why3" â‰” #why3; 

 symbol #change : Tactic;
 builtin "change" â‰” #change;

 
 // necessary in order to define the tactics
 protected symbol set0 : Set;
 rule Ï„ set0 â†ª Set;
 
  
symbol applyAny : ğ•ƒ tactic â†’ Tactic;
 rule applyAny ($t0 â¸¬ ($t1 â¸¬ $tl)) â†ª $t0 #orelse (applyAny ($t1 â¸¬ $tl))
 with applyAny ($t0 â¸¬ â–¡) â†ª $t0;
 
 symbol listOfAllSimpRules â‰” ((#rewrite "" "" âˆ¨_idem) â¸¬ (#rewrite "" "" em_eq_l) â¸¬ (#rewrite "" "" em_eq_r) â¸¬ (#rewrite "" "" âˆ¨âŠ¤) â¸¬ 
     (#rewrite "" "" âŠ¤âˆ¨) â¸¬ (#rewrite "" "" âˆ¨âŠ¥) â¸¬ (#rewrite "" "" âŠ¥âˆ¨) â¸¬ (#rewrite "" "" âˆ§_idem) â¸¬ (#rewrite "" "" âˆ§_contra_r) â¸¬ (#rewrite "" "" âˆ§_contra_l) â¸¬ 
     (#rewrite "" "" âˆ§âŠ¤) â¸¬ (#rewrite "" "" âŠ¤âˆ§) â¸¬ (#rewrite "" "" âˆ§âŠ¥) â¸¬ (#rewrite "" "" âŠ¥âˆ§) â¸¬ (#rewrite "" "" â‡’âŠ¤) â¸¬ (#rewrite "" "" âŠ¥â‡’) â¸¬ (#rewrite "" "" âŠ¤â‡’) â¸¬ 
     (#rewrite "" "" â‡’âŠ¥) â¸¬ (#rewrite "" "" â‡’_idem) â¸¬ (#rewrite "" "" â‡”âŠ¤) â¸¬ (#rewrite "" "" âŠ¤â‡”) â¸¬ (#rewrite "" "" âŠ¥â‡”) â¸¬ (#rewrite "" "" â‡”âŠ¥) â¸¬ 
     (#rewrite "" "" â‡”_idem) â¸¬ (#rewrite "" "" Â¬âŠ¤) â¸¬ (#rewrite "" "" Â¬âŠ¥) â¸¬ (#rewrite "" "" Â¬Â¬â‚‘_eq) â¸¬ (#rewrite "" "" =âŠ¤) â¸¬ (#rewrite "" "" âŠ¤=) â¸¬ 
     (#rewrite "" "" =âŠ¥) â¸¬ (#rewrite "" "" âŠ¥=) â¸¬ (#rewrite "" "" =_idem) â¸¬ (#rewrite "" "" Â¬=âŠ¥) â¸¬ (#rewrite "" "" Â¬âŠ¥=) â¸¬ (#rewrite "" "" Â¬=âŠ¤) â¸¬ 
     (#rewrite "" "" Â¬âŠ¤=) â¸¬ (#rewrite "" "" Â¬=_idem) â¸¬ (#rewrite "" "" âˆ€_const) â¸¬ (#rewrite "" "" âˆƒ_const) â¸¬ (#rewrite "" "" Â¬x=_idem) â¸¬ (#rewrite "" "" =Â¬x_idem) â¸¬ 
     (#rewrite "" "" polarity_switch) â¸¬ (#refine "âŠ¤áµ¢") â¸¬ â–¡);
     // the rules and ... are added as Leo omits trivially false literals, we account for this using this rule
 
 symbol applyAllSimplifications â‰” #repeat (applyAny listOfAllSimpRules);


/******************************************************************************
*  Definition of additional rules for clausification      
******************************************************************************/

opaque symbol Â¬âˆ€=âˆƒÂ¬ (t : Set) (p : Ï„ (t â¤³ o)) : //lemma6
Ï€ (Â¬(âˆ€ p) = (`âˆƒ (x : Ï„ t), Â¬ (p x)))â‰”
begin
assume t p;
refine propExt (Â¬ (âˆ€ p)) (`âˆƒ x, Â¬ (p x)) _ _
{assume h;
    refine âˆ¨â‚‘ (em (`âˆƒ x, Â¬ p x)) _ _
    {assume he; refine he}
    {assume hne;
        have forall_p : Î  x : Ï„ t, Ï€ (p x)
            {assume a; refine Â¬Â¬â‚‘ (p a) (Î» hp, hne (âˆƒáµ¢ [t] [Î» y, Â¬ p y] a hp))};
        refine âŠ¥â‚‘ (h (Î» a, forall_p a))}}
{assume h h2;
    refine âˆƒâ‚‘ [t] [Î» y, Â¬ p y] h (Î» a hna, hna (h2 a))}
end;

opaque symbol Â¬âˆƒ=âˆ€Â¬ (t : Set) (p : Ï„ (t â¤³ o)) : // lemma7
Ï€ (Â¬(âˆƒ p) = (`âˆ€ (x : Ï„ t), Â¬ p x))â‰”     
begin
assume t p;
refine propExt (Â¬ (âˆƒ p)) (`âˆ€ x, Â¬ p x) _ _
{assume h a ha; refine h (âˆƒáµ¢ [t] [p] a ha)}
{assume h1 h2; refine âˆƒâ‚‘ [t] [p] h2 (Î» a ha, (h1 a) ha)}
end;


//  Skolemisazion


opaque symbol Îµáµ¢_rev :  Î  [a: Set], Î  p: (Ï„ a â†’ Prop),  Ï€ (p (Îµ p)) â†’ Ï€ (âˆƒ p)â‰”
begin
assume a p h;
refine âˆƒáµ¢ [a] [p] (Îµ p) h
end;

opaque symbol âˆƒ_skolem (a: Set) (p: Ï„ (a â¤³ o)) :  
 Ï€ ((âˆƒ p) = (p (Îµ p)))â‰”
begin
 assume a p;
 refine propExt (âˆƒ p) (p (Îµ p)) (Îµáµ¢ [a] p) (Îµáµ¢_rev [a] p)
end;

opaque symbol âˆ€_skolem (a: Set) (p: Ï„ (a â¤³ o)) :  
Ï€ (Â¬ (âˆ€ p) = Â¬ (p (Îµ (Î» x, Â¬ (p x)))))â‰”
begin
assume a p;
rewrite Â¬âˆ€=âˆƒÂ¬;
refine  propExt (`âˆƒ x, Â¬ (p x)) (Â¬ (p (Îµ (Î» x, Â¬ (p x))))) _ _
    {assume h; refine ind_eq (eq_sym (âˆƒ_skolem a (Î» x, Â¬ (p x)))) (Î» x, x) h}
    {assume h; refine ind_eq (âˆƒ_skolem a (Î» x, Â¬ (p x))) (Î» x, x) h}
end;


//Quantifier Distributivity

opaque symbol âˆ€âˆ§_dist_r t a (p : Ï„(t â¤³ o)): Ï€ ((a âˆ§ âˆ€ p) = (`âˆ€ x, a âˆ§ p x))â‰”
begin
    assume t a p;
    refine propExt (a âˆ§ âˆ€ p) (âˆ€(Î» x, a âˆ§ p x)) _ _
        {assume h x;
        refine âˆ§áµ¢ (âˆ§â‚‘â‚ h) ((âˆ§â‚‘â‚‚ h) x)}
        {assume h;
        refine âˆ¨â‚‘ (em (âˆ€ p)) _ _
            {assume h1;
            refine âˆ§áµ¢ (âˆ§â‚‘â‚ (h (el t))) h1}
            {assume h1;
            have H0: Ï€ (Â¬ (p (Îµ (Î» x, Â¬ (p x)))))
                {refine =â‡’ (âˆ€_skolem t p) h1};
            have H1: Ï€ (p (Îµ (Î» x, Â¬ (p x))))
                {refine âˆ§â‚‘â‚‚ (h (Îµ (Î» x, Â¬ (p x))))};
            refine âŠ¥â‚‘ (H0 H1)}}
end;

opaque symbol âˆ€âˆ§_dist_l t a (p : Ï„(t â¤³ o)): Ï€ ((âˆ€ p âˆ§ a) = (`âˆ€ x,p x âˆ§ a))â‰”
begin
    assume t a p;
    refine propExt (âˆ€ p âˆ§ a) (`âˆ€ x, p x âˆ§ a) _ _
        {assume h0 x;
        rewrite âˆ§_com;
        refine (=â‡’ ((âˆ€âˆ§_dist_r t a p)) (=â‡’ (âˆ§_com (âˆ€ p) a) h0)) x
        }
        {assume h0;
        rewrite âˆ§_com;
        have H0: Ï€ (`âˆ€ x, a âˆ§ p x)
            {assume x;
            rewrite âˆ§_com;
            refine h0 x};
        refine =â‡’ (eq_sym (âˆ€âˆ§_dist_r t a p)) H0
        };
end;

opaque symbol âˆ€âˆ¨_dist_r t a (p : Ï„(t â¤³ o)): Ï€ ((a âˆ¨ âˆ€ p) = (`âˆ€ x, a âˆ¨ p x))â‰”
begin
    assume t a p;
    refine propExt (a âˆ¨ âˆ€ p) (âˆ€(Î» x, a âˆ¨ p x)) _ _
        {assume h x;
        refine âˆ¨â‚‘ h _ _
            {assume h0;
            refine âˆ¨áµ¢â‚ h0}
            {assume h0;
            refine âˆ¨áµ¢â‚‚ (h0 x)}}
        {assume h;
        refine âˆ¨â‚‘ (em (âˆ€ p)) _ _
            {assume h1;
            refine âˆ¨áµ¢â‚‚ h1}
            {assume h1;
            have H0: Ï€ (Â¬ (p (Îµ (Î» x, Â¬ (p x)))))
                {refine =â‡’ (âˆ€_skolem t p) h1};
            refine âˆ¨â‚‘ (h (Îµ (Î» x, Â¬ (p x)))) _ _
                {assume h0;
                refine âˆ¨áµ¢â‚ h0}
                {assume h0;
                refine âŠ¥â‚‘ (H0 h0)}}}
end;

opaque symbol âˆ€âˆ¨_dist_l t a (p : Ï„(t â¤³ o)): Ï€ ((âˆ€ p âˆ¨ a) = (`âˆ€ x,p x âˆ¨ a))â‰”
begin
    assume t a p;
    refine propExt (âˆ€ p âˆ¨ a) (`âˆ€ x,p x âˆ¨ a) _ _
        {assume h0 x;
        rewrite âˆ¨_com;
        refine (=â‡’ ((âˆ€âˆ¨_dist_r t a p)) (=â‡’ (âˆ¨_com (âˆ€ p) a) h0)) x}
        {assume h0;
        rewrite âˆ¨_com;
        have H0: Ï€ (`âˆ€ x, a âˆ¨ p x)
            {assume x;
            rewrite âˆ¨_com;
            refine h0 x};
        refine =â‡’ (eq_sym (âˆ€âˆ¨_dist_r t a p)) H0};
end;

opaque symbol âˆ€_ext [t: Set] [p q] : Ï€(`âˆ€ (x : Ï„ t), p x = q x) â†’ Ï€ ((`âˆ€ (x: Ï„ t), p x) = (`âˆ€ (x: Ï„ t), q x))â‰”
begin
    assume t p q h;
    refine propExt (`âˆ€ (x: Ï„ t), p x) (`âˆ€ (x: Ï„ t), q x) _ _
        {assume h1 x;
        refine =â‡’ (h x) (h1 x)}
        {assume h1 x;
        refine =â‡’ (eq_sym (h x)) (h1 x)}
end;

/******************************************************************************
*  Definition of Leo-III clausification tactic        
******************************************************************************/

symbol normAsso â‰” #repeat ((#rewrite "" "" âˆ§_assoc) #orelse (#rewrite "" "" âˆ¨_assoc));

symbol normAsso_âˆ¨ â‰” #repeat (#rewrite "" "" âˆ¨_assoc);

symbol normAsso_âˆ§ â‰” #repeat (#rewrite "" "" âˆ§_assoc);

symbol allCNFids_list â‰” ((#rewrite "" "" deMorgan_âˆ§) â¸¬ (#rewrite "" "" deMorgan_âˆ¨) â¸¬ (#rewrite "" "" â‡’=âˆ¨) â¸¬ (#rewrite "" "" Â¬â‡’=âˆ§Â¬) â¸¬ (#and (#rewrite "" "" âˆ§âˆ¨_dist_l) normAsso) â¸¬ (#and (#rewrite "" "" âˆ§âˆ¨_dist_r) normAsso) â¸¬ (#rewrite "" "" Â¬Â¬â‚‘_eq) â¸¬ (#rewrite "" "" âˆ¨_assoc) â¸¬ (#rewrite "" "" âˆ§_assoc) â¸¬ â–¡);

symbol boolIds â‰” (applyAny allCNFids_list);

symbol tryVars: ğ•ƒ string â†’ Tactic; 
rule tryVars ($v0 â¸¬ ($v1 â¸¬ $vs)) â†ª (#assume $v0) #orelse (tryVars ($v1 â¸¬ $vs))
with tryVars ($v0 â¸¬ â–¡) â†ª (#assume $v0);

symbol move_âˆ€_out (varList: ğ•ƒ string) â‰” #repeat (((#rewrite "" "" âˆ€âˆ§_dist_r) #orelse (#rewrite  "" "" âˆ€âˆ§_dist_l) #orelse (#rewrite  "" "" âˆ€âˆ¨_dist_r) #orelse (#rewrite "" "" âˆ€âˆ¨_dist_l)) #orelse (#and (#and (#refine "âˆ€_ext _ _ _") (#simplify_beta))) (tryVars varList));

symbol move_Â¬âˆƒ_out (varList: ğ•ƒ string) â‰” (#and (#rewrite "" "" Â¬âˆƒ=âˆ€Â¬) (move_âˆ€_out varList));

symbol generalizeQuant (varList: ğ•ƒ string) â‰” (move_âˆ€_out varList) #orelse (move_Â¬âˆƒ_out varList);

symbol skolemProzess_âˆƒ sk_def : Tactic â‰” (#and (#and (#rewrite "" "" âˆƒ_skolem) #simplify_beta) sk_def);

symbol skolemProzess_âˆ€ sk_def : Tactic â‰” (#and (#and (#rewrite "" "" âˆ€_skolem) #simplify_beta) sk_def);

symbol skolemProzess sk_def : Tactic â‰” (skolemProzess_âˆ€ sk_def) #orelse (skolemProzess_âˆƒ sk_def);

symbol stepwise_quants: ğ•ƒ tactic â†’ Tactic;
rule stepwise_quants ($sk1 â¸¬ ($sk2 â¸¬ $sk3)) â†ª #repeat ((#and $sk1 (stepwise_quants ($sk2 â¸¬ $sk3))) #orelse boolIds)
with stepwise_quants ($sk1 â¸¬ â–¡) â†ª #and (#repeat ($sk1 #orelse boolIds)) #reflexivity;

symbol move_âˆ€_out2 (assumeVar: Tactic) â‰” ((#and (#and (((#and (#repeat  (#rewrite "" ".[x in x = _]" Â¬Â¬â‚‘_eq)) (#refine "âˆ€_ext _"))) #orelse (#refine "âˆ€_ext _")) (#simplify_beta)) assumeVar) #orelse ((#rewrite "" "" âˆ€âˆ§_dist_r) #orelse (#rewrite  "" "" âˆ€âˆ§_dist_l) #orelse (#rewrite  "" "" âˆ€âˆ¨_dist_r) #orelse (#rewrite "" "" âˆ€âˆ¨_dist_l)));
symbol move_Â¬âˆƒ_out2 (assumeVar: Tactic) â‰” (#and (#rewrite "" "" Â¬âˆƒ=âˆ€Â¬) (move_âˆ€_out2 assumeVar));

symbol singleStepQuant: Tactic â†’ Tactic;
rule singleStepQuant $t â†ª #repeat ($t #orelse boolIds);

symbol lastStepQuant: Tactic â†’ Tactic;
rule lastStepQuant $t â†ª #and (#repeat ($t #orelse boolIds)) #reflexivity;

symbol stepwise_skolem0: ğ•ƒ tactic â†’ Tactic;
rule stepwise_skolem0 ($sk1 â¸¬ ($sk2 â¸¬ $sk3)) â†ª #repeat ((#and (skolemProzess $sk1) (stepwise_skolem0 ($sk2 â¸¬ $sk3))) #orelse boolIds)
with stepwise_skolem0 ($sk1 â¸¬ â–¡) â†ª #and (#repeat ((skolemProzess $sk1) #orelse boolIds)) #reflexivity;

symbol stepwise_skolem: (Tactic â†’ Tactic) â†’ ğ•ƒ tactic â†’ Tactic;
rule stepwise_skolem $t ($sk1 â¸¬ ($sk2 â¸¬ $sk3)) â†ª #repeat ((#and ($t $sk1) (stepwise_skolem $t ($sk2 â¸¬ $sk3))) #orelse boolIds)
with stepwise_skolem $t ($sk1 â¸¬ â–¡) â†ª #and (#repeat (($t $sk1) #orelse boolIds)) #reflexivity;

symbol handleQuants (varList: ğ•ƒ string) (allSkolemRW : ğ•ƒ tactic) â‰” ((stepwise_skolem skolemProzess_âˆ€ allSkolemRW) #orelse (move_âˆ€_out varList)) #orelse ((move_Â¬âˆƒ_out varList) #orelse (stepwise_skolem skolemProzess_âˆƒ allSkolemRW));

symbol cnfTac : ğ•ƒ string â†’ ğ•ƒ tactic â†’ Tactic;
rule cnfTac â–¡ â–¡ â†ª #and (#repeat boolIds) #reflexivity
with cnfTac ($v0 â¸¬ $v) â–¡ â†ª  #repeat ((generalizeQuant ($v0 â¸¬ $v)) #orelse boolIds)
with cnfTac â–¡ ($s0 â¸¬ $s) â†ª  stepwise_skolem skolemProzess ($s0 â¸¬ $s)
with cnfTac ($v0 â¸¬ $v) ($s0 â¸¬ $s) â†ª #repeat ((handleQuants ($v0 â¸¬ $v) ($s0 â¸¬ $s)) #orelse boolIds);