/* Library on proving the normalisazion to CNF by reflection

-------------------

The clausification process is split up into four seperate processes:

** Negation Normal Form:
    A number of standard rules are applied exhaustiveley:
    - Rules like the Demorgan rules and double literal deletion are applied to move negation inwards.
    - Negated universal quantifiers are transformed to existential quantifiers and vice versa. 
    - Implications is replaced by a disjunction (where the LHS of the implication is negated)

** Quantifier Generalisazion (WIP)
   Universal quantifiers are moved to the outer scope of the formulas

** Distributivity:
   Disjunctions vontaining Conjunctions are rewritten to conjunctions of disjunctions.

** Associativity: (WIP)
   ...
   
*/

require open Stdlib.FunExt;
require open Stdlib.Impred Stdlib.PropExt;
require open Leo-III-lambdapi-lib.MetaTheorems;
require open Leo-III-lambdapi-lib.Skolemisazion;

// Add to Std lib?
symbol âˆ¨_sym x y : Ï€ ((x âˆ¨ y) = (y âˆ¨ x))â‰”
begin
    assume x y;
    refine propExt (x âˆ¨ y) (y âˆ¨ x) _ _
        {assume h0;
        refine âˆ¨â‚‘ h0 _ _
            {assume h1; refine âˆ¨áµ¢â‚‚ h1}
            {assume h1; refine âˆ¨áµ¢â‚ h1}}
        {assume h0;
        refine âˆ¨â‚‘ h0 _ _
            {assume h1; refine âˆ¨áµ¢â‚‚ h1}
            {assume h1; refine âˆ¨áµ¢â‚ h1}}
end;

symbol âˆ§_sym x y : Ï€ ((x âˆ§ y) = (y âˆ§ x))â‰”
begin
    assume x y;
    refine propExt (x âˆ§ y) (y âˆ§ x) _ _
        {assume h0; refine âˆ§áµ¢ (âˆ§â‚‘â‚‚ h0) (âˆ§â‚‘â‚ h0)}
        {assume h0; refine âˆ§áµ¢ (âˆ§â‚‘â‚‚ h0) (âˆ§â‚‘â‚ h0)}
end;

symbol âˆ§_asso a b : 
    Ï€ ((a âˆ§ (b âˆ§ a)) = (b âˆ§ a)) â‰”
begin
    assume a b;
    refine propExt (a âˆ§ (b âˆ§ a)) (b âˆ§ a) _ _
        {assume h0; refine âˆ§â‚‘â‚‚ h0}
        {assume h0; refine âˆ§áµ¢ (âˆ§â‚‘â‚‚ h0) h0}
end;

symbol eta_exp [a] [b] (f : Ï„ a â†’ Ï„ b) :  
    Ï€ (f = (Î» y , f y))â‰”
begin
    assume a b f;
    refine funExt f (Î» y , f y) _;
    simplify; reflexivity
end;

symbol a : Prop;
symbol b : Prop;
symbol c : Prop;
symbol d : Prop;
symbol e : Prop;
symbol p: Ï„ Î¹ â†’ Prop;


////////////////////////////////////////////////////////////////////////////////
/////////////////////////// Negation Normal Form ///////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Setup

inductive nnf_prop: TYPE â‰”
| nnf_Other: Prop â†’ nnf_prop
| nnf_Neg: nnf_prop â†’ nnf_prop
| nnf_And: nnf_prop â†’ nnf_prop â†’ nnf_prop
| nnf_OR: nnf_prop â†’ nnf_prop â†’ nnf_prop
| nnf_Impl: nnf_prop â†’ nnf_prop â†’ nnf_prop
| nnf_Forall [a : Set] : (Ï„ a â†’ nnf_prop) â†’ nnf_prop
| nnf_Exists [a : Set] : (Ï„ a â†’ nnf_prop) â†’ nnf_prop;

symbol nnf_propS: Set;
rule Ï„ nnf_propS â†ª nnf_prop;

sequential symbol nnf_reify: Prop â†’ nnf_prop;
rule nnf_reify ($x âˆ§ $y) â†ª (nnf_And (nnf_reify $x) (nnf_reify $y))
with nnf_reify ($x âˆ¨ $y) â†ª (nnf_OR (nnf_reify $x) (nnf_reify $y))
with nnf_reify ($x â‡’ âŠ¥) â†ª  (nnf_Neg (nnf_reify $x)) 
with nnf_reify ($x â‡’ $y) â†ª (nnf_Impl (nnf_reify $x) (nnf_reify $y))
with nnf_reify (âˆ€ $p) â†ª (nnf_Forall (Î» x, (nnf_reify ($p x)))) 
with nnf_reify (âˆƒ $p) â†ª (nnf_Exists (Î» x, (nnf_reify ($p x)))) 
with nnf_reify $x â†ª (nnf_Other $x);

symbol nnf_denote (p: nnf_prop): Prop;
rule nnf_denote (nnf_And $x $y) â†ª  (nnf_denote $x) âˆ§ (nnf_denote $y)
with nnf_denote (nnf_Neg $x) â†ª  Â¬ (nnf_denote $x)
with nnf_denote (nnf_OR $x $y) â†ª  (nnf_denote $x) âˆ¨ (nnf_denote $y)
with nnf_denote (nnf_Impl $x $y) â†ª  (nnf_denote $x) â‡’ (nnf_denote $y)
with nnf_denote (nnf_Forall $p) â†ª  âˆ€(Î» x, nnf_denote ($p x))
with nnf_denote (nnf_Exists $p) â†ª  âˆƒ(Î» x, nnf_denote ($p x))
with nnf_denote (nnf_Other $i) â†ª $i;

symbol nnf: nnf_prop â†’ nnf_prop;
rule nnf (nnf_Neg (nnf_Neg $x)) â†ª nnf $x //Dne
with nnf (nnf_Neg (nnf_Impl $x $y)) â†ª nnf_And (nnf $x) (nnf (nnf_Neg $y)) // Imp_neg
with nnf (nnf_Neg (nnf_And $x $y)) â†ª nnf_OR (nnf (nnf_Neg $x)) (nnf (nnf_Neg $y)) // Demorgan_âˆ§ 
with nnf (nnf_Neg (nnf_OR $x $y)) â†ª nnf_And (nnf (nnf_Neg $x)) (nnf (nnf_Neg $y)) // Demorgan_âˆ¨
with nnf (nnf_Neg (nnf_Forall (Î» x, $F.[x]))) â†ª (nnf_Exists ((Î» x, nnf (nnf_Neg $F.[x])))) // Neg_All
with nnf (nnf_Neg (nnf_Forall (Î» x, $F.[]))) â†ª nnf (nnf_Neg $F.[]) // Eliminate quantifier
with nnf (nnf_Neg (nnf_Exists (Î» x, $F.[x]))) â†ª (nnf_Forall (Î» x,nnf (nnf_Neg $F.[x]))) // Neg_Ex
with nnf (nnf_Neg (nnf_Exists (Î» x, $F.[]))) â†ª nnf (nnf_Neg $F.[]) // Eliminate quantifier
with nnf (nnf_Neg (nnf_Other $x)) â†ª (nnf_Neg (nnf_Other $x))
with nnf (nnf_Impl $x $y) â†ª nnf_OR (nnf (nnf_Neg $x)) (nnf $y) // Imp
with nnf (nnf_OR $x $y) â†ª nnf_OR (nnf $x) (nnf $y)
with nnf (nnf_And $x $y) â†ª nnf_And (nnf $x) (nnf $y)
with nnf (nnf_Forall (Î» x, $F.[x])) â†ª (nnf_Forall (Î» x, nnf $F.[x]))
with nnf (nnf_Forall (Î» x, $F.[])) â†ª (nnf $F.[])
with nnf (nnf_Exists (Î» x, $F.[x])) â†ª (nnf_Exists (Î» x, nnf $F.[x]))
with nnf (nnf_Exists (Î» x, $F.[])) â†ª (nnf $F.[])
with nnf (nnf_Other $x) â†ª nnf_Other $x;


// Lemma

symbol nnf_denote_correct_Neg x : 
    Ï€ ((Â¬ (nnf_denote (nnf x))) = (nnf_denote (nnf (nnf_Neg x))))â‰”
begin
    have Â¬_exp: Î  x , Ï€ ((x â‡’ âŠ¥) = Â¬ x) {reflexivity};
    induction
        {reflexivity}
        {assume x0 h0; rewrite left h0; repeat rewrite Â¬_exp;
        rewrite Â¬Â¬â‚‘_eq (nnf_denote (nnf x0)); 
        reflexivity}
        {simplify; assume x0 h0 x1 h1;
        rewrite left h0; rewrite left h1;
        repeat rewrite  Â¬_exp; rewrite deMorgan_âˆ§; 
        reflexivity}
        {simplify; assume x0 h0 x1 h1;
        rewrite left h0; rewrite left h1;
        repeat rewrite  Â¬_exp; rewrite deMorgan_âˆ¨; 
        reflexivity}
        {simplify; assume x0 h0 x1 h1;
        rewrite left h0; rewrite left h1;
        repeat rewrite  Â¬_exp; rewrite deMorgan_âˆ¨; rewrite Â¬Â¬â‚‘_eq; reflexivity}  
        {assume a h0 h1; rewrite eta_exp h0; simplify; 
        rewrite  Â¬_exp; rewrite Â¬âˆ€=âˆƒÂ¬; simplify rule off;
        refine propExt (`âˆƒ x, Â¬ (nnf_denote (nnf (h0 x)))) (`âˆƒ x, nnf_denote (nnf (nnf_Neg (h0 x)))) _ _
            {assume h2; refine âˆƒâ‚‘ h2 _; assume y h3;
            have H0 : Ï€ (nnf_denote (nnf (nnf_Neg (h0 y))))
                {rewrite left h1 y; refine h3};
            refine âˆƒáµ¢ y H0}
            {assume h2; refine âˆƒâ‚‘ h2 _; assume y h3;
            have H0 : Ï€ ( Â¬ (nnf_denote (nnf (h0 y)))) 
                {rewrite h1 y; refine h3};
            refine âˆƒáµ¢ y H0}}
        {assume a f h0; rewrite eta_exp f; simplify; rewrite  Â¬_exp; rewrite Â¬âˆƒ=âˆ€Â¬; simplify rule off;
        refine propExt (`âˆ€ x, Â¬ (nnf_denote (nnf (f x)))) (`âˆ€ x, nnf_denote (nnf (nnf_Neg (f x)))) _ _
            {assume h1 y; rewrite left h0 y; refine h1 y}
            {assume h1 y; rewrite h0 y; refine h1 y}}      
end;


// Correctness Theorem 

symbol nnf_correct x : Ï€ (nnf_denote x = nnf_denote (nnf x))â‰”
begin
    induction
        {simplify; reflexivity}
        {assume x h0; rewrite left nnf_denote_correct_Neg; rewrite left h0; simplify; 
        reflexivity}
        {assume x h0 y h1; simplify; rewrite left h0; rewrite left h1; 
        reflexivity}
        {assume x h0 y h1; simplify; rewrite left h0; rewrite left h1; 
        reflexivity}
        {assume x h0 y h1; simplify; rewrite left nnf_denote_correct_Neg; rewrite left h0; 
        rewrite left h1; rewrite â‡’=âˆ¨; reflexivity}
        {assume a f h0; simplify; rewrite eta_exp f; simplify; 
        refine propExt (`âˆ€ x, nnf_denote ((Î» y, f y) x)) (nnf_denote (nnf (nnf_Forall (Î» y, f y)))) _ _ 
            {assume h1 z; rewrite left (h0 z) ; refine h1 z}
            {assume h1 z; rewrite (h0 z) ; refine h1 z}}
        {assume a f h0; rewrite eta_exp f; simplify;
        refine propExt (`âˆƒ x, nnf_denote (f x)) (`âˆƒ x, nnf_denote (nnf (f x))) _ _ 
            {assume h1; refine âˆƒâ‚‘ h1 _; assume y h2;
            have H0 : Ï€ (nnf_denote (nnf (f y)))
                {rewrite left h0 y; refine h2};
            refine âˆƒáµ¢ y H0}
            {assume h1; refine âˆƒâ‚‘ h1 _; assume y h2;
            have H0 : Ï€ (nnf_denote (f y))
                {rewrite h0 y; refine h2};
            refine âˆƒáµ¢ y H0}}
end;


// Application Example:

symbol nnf_example_0 : Ï€ ((Â¬ (a âˆ¨ b âˆ§ (a â‡’ a))) = ((Â¬ a) âˆ§ ((Â¬ b) âˆ¨ (a âˆ§ (Â¬ a))))) â‰”
begin

    have H0: Ï€ ((Â¬ (a âˆ¨ b âˆ§ (a â‡’ a))) = (nnf_denote (nnf_reify (Â¬ (a âˆ¨ b âˆ§ (a â‡’ a))))))
        {reflexivity};
    rewrite H0;
    rewrite .[x in x = _] nnf_correct;
    reflexivity; 
end;

symbol nnf_example_1 : Ï€ ((âˆ€(Î» x , Â¬ (p x âˆ¨ a âˆ§ (âˆƒ(Î» y, Â¬ (y â‡’ a)))))) = (`âˆ€ x, (Â¬ p x) âˆ§ ((Â¬ a) âˆ¨ (`âˆ€ x0, (Â¬ x0) âˆ¨ a)))) â‰”
begin

    have H0: Ï€ ((âˆ€(Î» x , Â¬ (p x âˆ¨ a âˆ§ (âˆƒ(Î» y, Â¬ (y â‡’ a)))))) = (nnf_denote (nnf_reify (âˆ€(Î» x , Â¬ (p x âˆ¨ a âˆ§ (âˆƒ(Î» y, Â¬ (y â‡’ a)))))))))
        {reflexivity};
    rewrite H0;
    rewrite .[x in x = _] nnf_correct;
    reflexivity; 
end;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// Distributivity //////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Setup

inductive dist_prop : TYPE â‰”
| dist_Other: Prop â†’ dist_prop
| dist_And: dist_prop â†’ dist_prop â†’ dist_prop
| dist_Or: dist_prop â†’ dist_prop â†’ dist_prop;

symbol dist_prop_S: Set;
rule Ï„ dist_prop_S â†ª dist_prop;

sequential symbol dist_reify: Prop â†’ dist_prop;
rule dist_reify ($x âˆ§ $y) â†ª (dist_And (dist_reify $x) (dist_reify $y))
with dist_reify ($x âˆ¨ $y) â†ª (dist_Or (dist_reify $x) (dist_reify $y))
with dist_reify $x â†ª (dist_Other $x);

symbol dist_denote: dist_prop â†’ Prop;
rule dist_denote (dist_And $x $y) â†ª (dist_denote $x) âˆ§ (dist_denote $y)
with dist_denote (dist_Or $x $y) â†ª (dist_denote $x) âˆ¨ (dist_denote $y)
with dist_denote (dist_Other $x) â†ª $x;

symbol prepend_each [a] : ğ•ƒ a â†’ ğ•ƒ (list a) â†’ ğ•ƒ (list a);
rule prepend_each $x â–¡ â†ª â–¡
with prepend_each $x ($l0 â¸¬ $l) â†ª ($x ++ $l0) â¸¬ (prepend_each $x $l);
symbol cartesian_prepend [a] : ğ•ƒ (list a) â†’ ğ•ƒ (list a) â†’ ğ•ƒ (list a);
rule cartesian_prepend ($l0 â¸¬ $l) $n â†ª (prepend_each $l0 $n) ++ (cartesian_prepend $l $n)
with cartesian_prepend â–¡ $n â†ª â–¡;

symbol dist_disj : ğ•ƒ dist_prop_S â†’ dist_prop;
rule dist_disj ($l0 â¸¬ ($l1 â¸¬ $l)) â†ª dist_Or $l0 (dist_disj ($l1 â¸¬ $l))
with dist_disj ($l0 â¸¬ â–¡) â†ª $l0
with dist_disj â–¡ â†ª dist_Other âŠ¥;

symbol dist_conj : ğ•ƒ (list dist_prop_S) â†’ dist_prop;
rule dist_conj ($l0 â¸¬ ($l1 â¸¬ $l)) â†ª dist_And (dist_disj $l0) (dist_conj ($l1 â¸¬ $l))
with dist_conj ($l0 â¸¬ â–¡) â†ª (dist_disj $l0)
with dist_conj â–¡ â†ª dist_Other âŠ¤;

symbol dist : dist_prop â†’ ğ•ƒ (list dist_prop_S);
rule dist (dist_And $x $y) â†ª (dist $x) ++ (dist $y)
with dist (dist_Other $x) â†ª (((dist_Other $x) â¸¬ â–¡) â¸¬ â–¡)
with dist (dist_Or $x $y) â†ª cartesian_prepend (dist $x) (dist $y);

// Lemmas

symbol dist_denote_correct_âˆ§ x y : 
    Ï€ (((dist_denote x) âˆ§ (dist_denote y)) = (dist_denote (dist_And x y)))â‰”
begin
    simplify; reflexivity;
end;

symbol dist_denote_correct_âˆ¨ x y : 
    Ï€ (((dist_denote x) âˆ¨ (dist_denote y)) = (dist_denote (dist_Or x y)))â‰”
begin
    simplify; reflexivity;
end;

symbol dist_denote_correct_++ x y : 
    Ï€ ((dist_denote (dist_And (dist_conj x) (dist_conj y))) = (dist_denote (dist_conj (x ++ y))))â‰”
begin
    induction
        {simplify; assume x; rewrite âŠ¤âˆ§; reflexivity}
        {assume x; induction
                {assume h0; induction
                    {simplify; rewrite âˆ§âŠ¤; reflexivity}
                    {assume y l h1; simplify; reflexivity}}
                {simplify; assume y l h0 h1 n; rewrite left h1 n; rewrite âˆ§_assoc; 
                reflexivity}}
end;

symbol dist_denote_correct_â¸¬ x y : 
    Ï€ (dist_denote (dist_conj (x â¸¬ y)) = dist_denote (dist_And (dist_disj x) (dist_conj y)))â‰”
begin
    induction
        {induction
            {simplify; rewrite âŠ¥âˆ§; reflexivity}
            {assume x0 x1 h0; reflexivity}}
        {assume x l h0; induction
                {simplify; rewrite âˆ§âŠ¤; reflexivity}
                {simplify; assume y n h1 ; reflexivity}}
end;

symbol prepend_each_add n0 n l: 
    Ï€ ((dist_denote (dist_conj (cartesian_prepend (n0 â¸¬ n) l))) = (dist_denote (dist_conj (cartesian_prepend n l)) âˆ§ dist_denote (dist_conj (cartesian_prepend (n0 â¸¬ n) l))))â‰”
begin
    assume n0 n l;
    refine propExt (dist_denote (dist_conj (cartesian_prepend (n0 â¸¬ n) l))) (dist_denote (dist_conj (cartesian_prepend n l)) âˆ§ dist_denote (dist_conj (cartesian_prepend (n0 â¸¬ n) l)))_ _ 
        {assume h0; refine âˆ§áµ¢ _ h0; 
        have H0 : Ï€ ((dist_denote (dist_conj (cartesian_prepend (n0 â¸¬ n) l))) â‡’ (dist_denote (dist_conj (cartesian_prepend n l))))
            {simplify cartesian_prepend; rewrite left dist_denote_correct_++; simplify; assume h1; refine âˆ§â‚‘â‚‚ h1};
        refine H0 h0}
        {assume h0; refine âˆ§â‚‘â‚‚ h0}
end;    

symbol dist_disj_corr_â¸¬ x y : 
    Ï€ ((dist_denote (dist_disj (x â¸¬ y))) = (dist_denote x âˆ¨ dist_denote (dist_disj y)))â‰”
begin
    assume x;
    induction
        {simplify; rewrite âˆ¨âŠ¥; reflexivity}
        {assume y0 y h0;
        simplify; reflexivity}
end;

symbol dist_disj_corr_++  x y : 
    Ï€ ((dist_denote (dist_disj (x ++ y))) = (dist_denote (dist_disj x) âˆ¨ dist_denote (dist_disj y)))â‰”
begin
    induction
        {simplify; assume x; rewrite âŠ¥âˆ¨; reflexivity}
        {assume x0 x h0 y;
        simplify; rewrite dist_disj_corr_â¸¬; rewrite dist_disj_corr_â¸¬; rewrite h0;
        rewrite âˆ¨_assoc;reflexivity}
end;

symbol cartesian_prepend_â¸¬_++ [a] (l0 : ğ•ƒ a) l n : 
    Ï€ ((cartesian_prepend (l0 â¸¬ l) n) = (prepend_each l0 n) ++ (cartesian_prepend l n))â‰”
begin
    assume l0 l n; simplify;
    reflexivity
end;

symbol cartesian_prepend_empty [a] (x : ğ•ƒ (list a)) : 
    Ï€ ((cartesian_prepend x â–¡) = â–¡)â‰”
begin
    assume a;
    induction
        {simplify; reflexivity}
        {simplify; assume x y h; refine h}
end;

symbol cartesian_prepend_sym n l :
     Ï€ ((dist_denote (dist_conj (cartesian_prepend l n))) = dist_denote (dist_conj (cartesian_prepend n l))) â‰”
begin
    induction
        {simplify; assume l; rewrite cartesian_prepend_empty; simplify; reflexivity}
        {assume l0 l h0; induction
            {rewrite cartesian_prepend_empty; simplify; 
            reflexivity}
            {assume n0 n h1; 
            rewrite cartesian_prepend_â¸¬_++; rewrite left dist_denote_correct_++; simplify dist_denote; rewrite h1; rewrite cartesian_prepend_â¸¬_++; 
            simplify prepend_each; rewrite dist_denote_correct_â¸¬; simplify dist_denote; rewrite left dist_denote_correct_++; simplify dist_denote;
            rewrite cartesian_prepend_â¸¬_++; rewrite left dist_denote_correct_++; simplify dist_denote; rewrite left h0 (n0 â¸¬ n); rewrite cartesian_prepend_â¸¬_++; 
            simplify prepend_each; rewrite dist_denote_correct_â¸¬; simplify dist_denote; rewrite left dist_denote_correct_++; simplify dist_denote;
            rewrite h0 n; rewrite dist_disj_corr_++; rewrite dist_disj_corr_++; rewrite âˆ¨_sym;
            have âˆ§_sym_3 : Î  x, Î  y, Î  z, Ï€ ((x âˆ§ y âˆ§ z) = (y âˆ§ x âˆ§ z))
                {assume x y z; rewrite âˆ§_sym; rewrite âˆ§_assoc; rewrite .[x in (_ âˆ§ x) = _] âˆ§_sym; 
                reflexivity};
            rewrite âˆ§_assoc; rewrite âˆ§_assoc; rewrite .[x in (_ âˆ§ x) = _] âˆ§_sym_3; 
            reflexivity}} 
end;

symbol cartesian_prepend_double l0 n0 l n : 
    Ï€ (dist_denote ( dist_conj (cartesian_prepend (l0 â¸¬ l) (n0 â¸¬ n))) = dist_denote (dist_conj ((l0 ++ n0) â¸¬ (cartesian_prepend (l0 â¸¬ l) (n)) ++ (cartesian_prepend (l) (n0 â¸¬ n)))))â‰”
begin
    assume l0 n0; assume l n; simplify; rewrite dist_denote_correct_â¸¬; rewrite dist_denote_correct_â¸¬; simplify dist_denote; simplify dist_denote;
    rewrite left dist_denote_correct_++; rewrite left dist_denote_correct_++; simplify dist_denote; simplify dist_denote; rewrite cartesian_prepend_sym; 
    rewrite left dist_denote_correct_++; simplify dist_denote; rewrite prepend_each_add; rewrite .[x in (_ âˆ§ _ âˆ§ _ âˆ§ x) = _] cartesian_prepend_sym; 
    rewrite .[x in (_ âˆ§ _ âˆ§ x âˆ§ _) = _] cartesian_prepend_sym; 
    reflexivity
end;

symbol cartesian_prepend_correct x y : 
    Ï€ (dist_denote (dist_Or (dist_conj x) (dist_conj y)) = dist_denote (dist_conj (cartesian_prepend x y)))â‰”
begin
    induction
        {simplify; assume x; rewrite âŠ¤âˆ¨; reflexivity}
        {assume x; assume l h0;
            induction
                {simplify; rewrite âˆ¨âŠ¤; type (h0 â–¡); rewrite left (h0 â–¡); simplify; rewrite âˆ¨âŠ¤; 
                reflexivity}
                {assume y z h1; simplify dist_denote; rewrite dist_denote_correct_â¸¬; rewrite dist_denote_correct_â¸¬; simplify dist_denote; 
                rewrite cartesian_prepend_double; rewrite dist_denote_correct_â¸¬; simplify dist_denote; rewrite left dist_denote_correct_++; 
                simplify dist_denote; rewrite left h1; rewrite left h0 (y â¸¬ z); simplify dist_denote; rewrite dist_denote_correct_â¸¬; 
                rewrite dist_denote_correct_â¸¬; rewrite dist_disj_corr_++; simplify; rewrite âˆ§âˆ¨_dist_l; rewrite âˆ§âˆ¨_dist_l; 
                rewrite âˆ§âˆ¨_dist_r; rewrite âˆ§âˆ¨_dist_r; rewrite âˆ§_assoc; rewrite âˆ§_assoc; rewrite âˆ§_asso; 
                reflexivity}}
end;


// Correctness Theorem 

symbol dist_correct l : 
    Ï€ (dist_denote l = dist_denote (dist_conj (dist l)))â‰”
begin
    induction
        {simplify; reflexivity}
        {simplify; assume x0 h0 x1 h1; rewrite h0; rewrite h1; 
        rewrite dist_denote_correct_âˆ§; rewrite dist_denote_correct_++;
        reflexivity}
        {simplify; assume x0 h0 x1 h1; rewrite h0; rewrite h1;
        rewrite dist_denote_correct_âˆ¨; rewrite cartesian_prepend_correct;
        reflexivity}
end;


// Application Example

symbol dist_example_0 : Ï€ ((a âˆ¨ b âˆ¨ c âˆ¨ (d âˆ§ e)) = ((a âˆ¨ (b âˆ¨ (c âˆ¨ d))) âˆ§ (a âˆ¨ (b âˆ¨ (c âˆ¨ e))))) â‰”
begin

    have H0: Ï€ ((a âˆ¨ b âˆ¨ c âˆ¨ (d âˆ§ e)) = (dist_denote (dist_reify (a âˆ¨ b âˆ¨ c âˆ¨ (d âˆ§ e)))))
        {reflexivity};
    rewrite H0;
    rewrite .[x in x = _] dist_correct;
    reflexivity; 
end;
